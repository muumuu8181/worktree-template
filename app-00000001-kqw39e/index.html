<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ§‹é€ åŠ›å­¦ãƒ»å¿œåŠ›è§£æã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 14px;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.3s;
        }

        .tab.active {
            background: white;
            color: #495057;
            border-bottom: 3px solid #007bff;
        }

        .tab:hover {
            background: #e9ecef;
        }

        .tab-content {
            display: none;
            padding: 25px;
            min-height: 600px;
        }

        .tab-content.active {
            display: block;
        }

        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
            font-size: 12px;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #007bff;
        }

        .btn {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #0056b3;
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            background: #5a6268;
        }

        .btn.danger {
            background: #dc3545;
        }

        .btn.danger:hover {
            background: #c82333;
        }

        .canvas-container {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .canvas-container canvas {
            display: block;
            cursor: crosshair;
        }

        .results-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .result-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .result-card h4 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .result-value {
            font-size: 18px;
            font-weight: 700;
            color: #007bff;
        }

        .result-unit {
            font-size: 12px;
            color: #6c757d;
            margin-left: 5px;
        }

        .material-db {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .material-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s;
        }

        .material-card:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .material-card.selected {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #e9ecef;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .stress-colorbar {
            display: flex;
            height: 20px;
            margin: 10px 0;
            border-radius: 10px;
            overflow: hidden;
        }

        .stress-level {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        .tutorial {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .tutorial h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .tutorial p {
            color: #856404;
            font-size: 14px;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .tabs {
                flex-direction: column;
            }

            .control-row {
                flex-direction: column;
                align-items: stretch;
            }

            .canvas-container canvas {
                max-width: 100%;
                height: auto;
            }
        }

        .analysis-progress {
            background: #e9ecef;
            border-radius: 10px;
            height: 10px;
            margin: 15px 0;
            overflow: hidden;
        }

        .analysis-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            border-radius: 10px;
            transition: width 0.3s;
            width: 0%;
        }

        .node-info, .element-info {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .calculation-steps {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }

        .success-message {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ—ï¸ æ§‹é€ åŠ›å­¦ãƒ»å¿œåŠ›è§£æã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
            <p>ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªæ§‹é€ è§£æã¨ãƒˆãƒ©ã‚¹ãƒ»æ¢ã®å¿œåŠ›è¨ˆç®—ãƒ„ãƒ¼ãƒ«</p>
        </div>

        <div class="main-content">
            <div class="tabs">
                <button class="tab active" data-tab="truss">ãƒˆãƒ©ã‚¹è§£æ</button>
                <button class="tab" data-tab="beam">æ¢ã®è§£æ</button>
                <button class="tab" data-tab="materials">ææ–™ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</button>
                <button class="tab" data-tab="learning">å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰</button>
                <button class="tab" data-tab="examples">ä¾‹é¡Œé›†</button>
            </div>

            <!-- ãƒˆãƒ©ã‚¹è§£æã‚¿ãƒ– -->
            <div class="tab-content active" id="truss">
                <div class="tutorial">
                    <h4>ğŸ“š ãƒˆãƒ©ã‚¹æ§‹é€ è§£æ</h4>
                    <p>ç¯€ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é…ç½®ã—ã€éƒ¨æã§æ¥ç¶šã—ã¦ãƒˆãƒ©ã‚¹æ§‹é€ ã‚’ä½œæˆã§ãã¾ã™ã€‚å¢ƒç•Œæ¡ä»¶ã¨è·é‡ã‚’è¨­å®šã—ã¦å¿œåŠ›è§£æã‚’å®Ÿè¡Œã—ã¾ã—ã‚‡ã†ã€‚</p>
                </div>

                <div class="control-panel">
                    <div class="control-row">
                        <div class="control-group">
                            <label>è§£æãƒ¢ãƒ¼ãƒ‰</label>
                            <select id="analysisMode">
                                <option value="static">é™çš„è§£æ</option>
                                <option value="modal">å›ºæœ‰å€¤è§£æ</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰</label>
                            <select id="displayMode">
                                <option value="structure">æ§‹é€ å›³</option>
                                <option value="stress">å¿œåŠ›åˆ†å¸ƒ</option>
                                <option value="deformation">å¤‰å½¢å›³</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>å¤‰å½¢å€ç‡</label>
                            <input type="range" id="deformScale" min="1" max="100" value="10">
                            <span id="deformScaleValue">10x</span>
                        </div>
                    </div>
                    <div class="control-row">
                        <button class="btn" onclick="addNode()">ç¯€ç‚¹è¿½åŠ </button>
                        <button class="btn" onclick="addElement()">éƒ¨æè¿½åŠ </button>
                        <button class="btn secondary" onclick="setSupport()">æ”¯æŒæ¡ä»¶</button>
                        <button class="btn secondary" onclick="setLoad()">è·é‡è¨­å®š</button>
                        <button class="btn" onclick="analyzeStructure()">è§£æå®Ÿè¡Œ</button>
                        <button class="btn danger" onclick="clearStructure()">ã‚¯ãƒªã‚¢</button>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="trussCanvas" width="800" height="500"></canvas>
                    <div class="node-info" id="nodeInfo"></div>
                    <div class="element-info" id="elementInfo"></div>
                </div>

                <div class="analysis-progress">
                    <div class="analysis-progress-bar" id="progressBar"></div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #007bff;"></div>
                        <span>ç¯€ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #28a745;"></div>
                        <span>éƒ¨æï¼ˆåœ§ç¸®ï¼‰</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #dc3545;"></div>
                        <span>éƒ¨æï¼ˆå¼•å¼µï¼‰</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffc107;"></div>
                        <span>æ”¯æŒç‚¹</span>
                    </div>
                </div>

                <div class="results-panel">
                    <h3>è§£æçµæœ</h3>
                    <div class="results-grid">
                        <div class="result-card">
                            <h4>æœ€å¤§å¿œåŠ›</h4>
                            <div class="result-value" id="maxStress">0<span class="result-unit">MPa</span></div>
                        </div>
                        <div class="result-card">
                            <h4>æœ€å¤§å¤‰ä½</h4>
                            <div class="result-value" id="maxDisp">0<span class="result-unit">mm</span></div>
                        </div>
                        <div class="result-card">
                            <h4>å®‰å…¨ä¿‚æ•°</h4>
                            <div class="result-value" id="safetyFactor">âˆ<span class="result-unit">-</span></div>
                        </div>
                        <div class="result-card">
                            <h4>ç·é‡é‡</h4>
                            <div class="result-value" id="totalWeight">0<span class="result-unit">kg</span></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ¢ã®è§£æã‚¿ãƒ– -->
            <div class="tab-content" id="beam">
                <div class="tutorial">
                    <h4>ğŸ“š æ¢ã®æ›²ã’è§£æ</h4>
                    <p>æ¢ã®é•·ã•ã€æ”¯æŒæ¡ä»¶ã€è·é‡æ¡ä»¶ã‚’è¨­å®šã—ã¦ã›ã‚“æ–­åŠ›å›³ãƒ»æ›²ã’ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆå›³ã‚’ä½œæˆã§ãã¾ã™ã€‚</p>
                </div>

                <div class="control-panel">
                    <div class="control-row">
                        <div class="control-group">
                            <label>æ¢ã®é•·ã• (m)</label>
                            <input type="number" id="beamLength" value="6" min="1" max="20" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>æ–­é¢å½¢çŠ¶</label>
                            <select id="beamSection">
                                <option value="rectangular">çŸ©å½¢æ–­é¢</option>
                                <option value="circular">å††å½¢æ–­é¢</option>
                                <option value="i-beam">Iå½¢æ–­é¢</option>
                                <option value="h-beam">Hå½¢æ–­é¢</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>æ”¯æŒæ¡ä»¶</label>
                            <select id="supportType">
                                <option value="simple">å˜ç´”æ¢</option>
                                <option value="cantilever">ç‰‡æŒã¡æ¢</option>
                                <option value="fixed">ä¸¡ç«¯å›ºå®šæ¢</option>
                                <option value="continuous">é€£ç¶šæ¢</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group">
                            <label>è·é‡ã‚¿ã‚¤ãƒ—</label>
                            <select id="loadType">
                                <option value="point">é›†ä¸­è·é‡</option>
                                <option value="distributed">åˆ†å¸ƒè·é‡</option>
                                <option value="moment">ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆè·é‡</option>
                                <option value="triangular">ä¸‰è§’å½¢åˆ†å¸ƒè·é‡</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>è·é‡å€¤ (kN)</label>
                            <input type="number" id="loadValue" value="10" min="0" max="1000" step="1">
                        </div>
                        <div class="control-group">
                            <label>è·é‡ä½ç½® (m)</label>
                            <input type="number" id="loadPosition" value="3" min="0" max="20" step="0.1">
                        </div>
                    </div>
                    <div class="control-row">
                        <button class="btn" onclick="addBeamLoad()">è·é‡è¿½åŠ </button>
                        <button class="btn" onclick="analyzeBeam()">è§£æå®Ÿè¡Œ</button>
                        <button class="btn secondary" onclick="generateReport()">ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</button>
                        <button class="btn danger" onclick="clearBeam()">ã‚¯ãƒªã‚¢</button>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="beamCanvas" width="800" height="600"></canvas>
                </div>

                <div class="chart-container">
                    <h4>ã›ã‚“æ–­åŠ›å›³ (SFD)</h4>
                    <canvas id="sfdCanvas" width="800" height="150"></canvas>
                </div>

                <div class="chart-container">
                    <h4>æ›²ã’ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆå›³ (BMD)</h4>
                    <canvas id="bmdCanvas" width="800" height="150"></canvas>
                </div>

                <div class="chart-container">
                    <h4>ãŸã‚ã¿å›³</h4>
                    <canvas id="deflectionCanvas" width="800" height="150"></canvas>
                </div>
            </div>

            <!-- ææ–™ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¿ãƒ– -->
            <div class="tab-content" id="materials">
                <div class="tutorial">
                    <h4>ğŸ“š ææ–™ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</h4>
                    <p>å„ç¨®æ§‹é€ ææ–™ã®ç‰¹æ€§å€¤ã‚’ç¢ºèªã—ã€è§£æã«ä½¿ç”¨ã™ã‚‹ææ–™ã‚’é¸æŠã§ãã¾ã™ã€‚</p>
                </div>

                <div class="control-panel">
                    <div class="control-row">
                        <div class="control-group">
                            <label>ææ–™ã‚«ãƒ†ã‚´ãƒª</label>
                            <select id="materialCategory" onchange="filterMaterials()">
                                <option value="all">ã™ã¹ã¦</option>
                                <option value="steel">é‹¼æ</option>
                                <option value="concrete">ã‚³ãƒ³ã‚¯ãƒªãƒ¼ãƒˆ</option>
                                <option value="wood">æœ¨æ</option>
                                <option value="aluminum">ã‚¢ãƒ«ãƒŸãƒ‹ã‚¦ãƒ </option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>æ¤œç´¢</label>
                            <input type="text" id="materialSearch" placeholder="ææ–™åã§æ¤œç´¢" oninput="filterMaterials()">
                        </div>
                    </div>
                </div>

                <div class="material-db" id="materialDatabase">
                    <!-- ææ–™ã‚«ãƒ¼ãƒ‰ãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
                </div>

                <div class="results-panel">
                    <h3>é¸æŠææ–™ã®è©³ç´°</h3>
                    <div id="materialDetails">
                        <p>ææ–™ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
                    </div>
                </div>
            </div>

            <!-- å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã‚¿ãƒ– -->
            <div class="tab-content" id="learning">
                <div class="tutorial">
                    <h4>ğŸ“š æ§‹é€ åŠ›å­¦å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰</h4>
                    <p>åŸºæœ¬ç†è«–ã‹ã‚‰å¿œç”¨ã¾ã§ã€æ§‹é€ åŠ›å­¦ã®æ¦‚å¿µã‚’ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«å­¦ç¿’ã§ãã¾ã™ã€‚</p>
                </div>

                <div class="control-panel">
                    <div class="control-row">
                        <div class="control-group">
                            <label>å­¦ç¿’ãƒˆãƒ”ãƒƒã‚¯</label>
                            <select id="learningTopic" onchange="loadLearningContent()">
                                <option value="basics">åŸºæœ¬æ¦‚å¿µ</option>
                                <option value="stress">å¿œåŠ›ã¨ã²ãšã¿</option>
                                <option value="truss-theory">ãƒˆãƒ©ã‚¹ç†è«–</option>
                                <option value="beam-theory">æ¢ç†è«–</option>
                                <option value="fem">æœ‰é™è¦ç´ æ³•</option>
                                <option value="safety">å®‰å…¨è¨­è¨ˆ</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>é›£æ˜“åº¦</label>
                            <select id="difficultyLevel">
                                <option value="beginner">åˆç´š</option>
                                <option value="intermediate">ä¸­ç´š</option>
                                <option value="advanced">ä¸Šç´š</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="learningContent">
                    <!-- å­¦ç¿’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
                </div>
            </div>

            <!-- ä¾‹é¡Œé›†ã‚¿ãƒ– -->
            <div class="tab-content" id="examples">
                <div class="tutorial">
                    <h4>ğŸ“š ä¾‹é¡Œé›†</h4>
                    <p>å®Ÿè·µçš„ãªä¾‹é¡Œã‚’é€šã—ã¦æ§‹é€ è§£æã®æ‰‹æ³•ã‚’å­¦ç¿’ã§ãã¾ã™ã€‚</p>
                </div>

                <div class="control-panel">
                    <div class="control-row">
                        <div class="control-group">
                            <label>ä¾‹é¡Œã‚«ãƒ†ã‚´ãƒª</label>
                            <select id="exampleCategory" onchange="loadExamples()">
                                <option value="truss">ãƒˆãƒ©ã‚¹å•é¡Œ</option>
                                <option value="beam">æ¢å•é¡Œ</option>
                                <option value="frame">ãƒ©ãƒ¼ãƒ¡ãƒ³å•é¡Œ</option>
                                <option value="practical">å®Ÿå‹™å•é¡Œ</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>é›£æ˜“åº¦</label>
                            <select id="exampleDifficulty">
                                <option value="basic">åŸºæœ¬</option>
                                <option value="standard">æ¨™æº–</option>
                                <option value="advanced">å¿œç”¨</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="examplesList">
                    <!-- ä¾‹é¡Œãƒªã‚¹ãƒˆãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let currentStructure = {
            nodes: [],
            elements: [],
            supports: [],
            loads: [],
            selectedMaterial: null
        };

        let currentBeam = {
            length: 6,
            section: 'rectangular',
            support: 'simple',
            loads: []
        };

        let isAnalyzing = false;
        let analysisResults = null;

        // ææ–™ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
        const materialDatabase = [
            {
                id: 'ss400',
                name: 'SS400',
                category: 'steel',
                E: 200000, // MPa
                fy: 235,   // MPa
                density: 7850, // kg/mÂ³
                poisson: 0.3
            },
            {
                id: 'sm490',
                name: 'SM490',
                category: 'steel',
                E: 200000,
                fy: 325,
                density: 7850,
                poisson: 0.3
            },
            {
                id: 'fc21',
                name: 'FC21',
                category: 'concrete',
                E: 21000,
                fc: 21,
                density: 2300,
                poisson: 0.2
            },
            {
                id: 'hinoki',
                name: 'ãƒ’ãƒã‚­',
                category: 'wood',
                E: 9000,
                fb: 32,
                density: 400,
                poisson: 0.3
            },
            {
                id: 'a6061',
                name: 'A6061-T6',
                category: 'aluminum',
                E: 70000,
                fy: 275,
                density: 2700,
                poisson: 0.33
            }
        ];

        // å­¦ç¿’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ‡ãƒ¼ã‚¿
        const learningContent = {
            basics: {
                title: 'æ§‹é€ åŠ›å­¦ã®åŸºæœ¬æ¦‚å¿µ',
                content: `
                    <h3>åŠ›ã¨ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ</h3>
                    <p>æ§‹é€ åŠ›å­¦ã§ã¯ã€æ§‹é€ ç‰©ã«ä½œç”¨ã™ã‚‹åŠ›ã¨ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆã‚’è§£æã—ã¾ã™ã€‚</p>
                    <ul>
                        <li><strong>åŠ› (Force)</strong>: ç‰©ä½“ã‚’å¤‰å½¢ã•ã›ãŸã‚Šé‹å‹•ã•ã›ãŸã‚Šã™ã‚‹ä½œç”¨ [N]</li>
                        <li><strong>ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ (Moment)</strong>: å›è»¢ã‚’ç”Ÿã˜ã•ã›ã‚‹åŠ›ã®ä½œç”¨ [NÂ·m]</li>
                        <li><strong>æ”¯ç‚¹ååŠ›</strong>: æ”¯æŒç‚¹ã§æ§‹é€ ç‰©ã‚’æ”¯ãˆã‚‹åŠ›</li>
                    </ul>
                    
                    <h3>å¹³è¡¡æ¡ä»¶</h3>
                    <p>é™çš„æ§‹é€ ç‰©ã§ã¯ä»¥ä¸‹ã®å¹³è¡¡æ¡ä»¶ã‚’æº€ãŸã™å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š</p>
                    <ul>
                        <li>Î£Fx = 0 (æ°´å¹³æ–¹å‘ã®åŠ›ã®é‡£ã‚Šåˆã„)</li>
                        <li>Î£Fy = 0 (é‰›ç›´æ–¹å‘ã®åŠ›ã®é‡£ã‚Šåˆã„)</li>
                        <li>Î£M = 0 (ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆã®é‡£ã‚Šåˆã„)</li>
                    </ul>
                    
                    <div class="interactive-demo">
                        <canvas id="basicsDemo" width="400" height="200"></canvas>
                        <button onclick="demoBasics()">ãƒ‡ãƒ¢å®Ÿè¡Œ</button>
                    </div>
                `
            },
            stress: {
                title: 'å¿œåŠ›ã¨ã²ãšã¿',
                content: `
                    <h3>å¿œåŠ› (Stress)</h3>
                    <p>ææ–™å†…éƒ¨ã®å˜ä½é¢ç©ã‚ãŸã‚Šã®å†…åŠ›ã‚’å¿œåŠ›ã¨ã„ã„ã¾ã™ã€‚</p>
                    <ul>
                        <li><strong>è»¸å¿œåŠ›</strong>: Ïƒ = P/A [MPa]</li>
                        <li><strong>æ›²ã’å¿œåŠ›</strong>: Ïƒ = M/Z [MPa]</li>
                        <li><strong>ã›ã‚“æ–­å¿œåŠ›</strong>: Ï„ = Q/A [MPa]</li>
                    </ul>
                    
                    <h3>ã²ãšã¿ (Strain)</h3>
                    <p>ææ–™ã®å¤‰å½¢ã®ç¨‹åº¦ã‚’è¡¨ã™ç„¡æ¬¡å…ƒé‡ã§ã™ã€‚</p>
                    <ul>
                        <li><strong>è»¸ã²ãšã¿</strong>: Îµ = Î´/L [-]</li>
                        <li><strong>ã›ã‚“æ–­ã²ãšã¿</strong>: Î³ = Î¸ [rad]</li>
                    </ul>
                    
                    <h3>ãƒ•ãƒƒã‚¯ã®æ³•å‰‡</h3>
                    <p>å¿œåŠ›ã¨ã²ãšã¿ã®é–¢ä¿‚: Ïƒ = EÂ·Îµ</p>
                    <p>E: å¼¾æ€§ä¿‚æ•° (ãƒ¤ãƒ³ã‚°ç‡) [MPa]</p>
                `
            }
        };

        // ä¾‹é¡Œãƒ‡ãƒ¼ã‚¿
        const exampleProblems = {
            truss: [
                {
                    id: 'truss_01',
                    title: 'å˜ç´”ãƒˆãƒ©ã‚¹ - åŸºæœ¬å•é¡Œ',
                    difficulty: 'basic',
                    description: '3ç¯€ç‚¹2éƒ¨æã®æœ€ã‚‚åŸºæœ¬çš„ãªãƒˆãƒ©ã‚¹æ§‹é€ ã®è§£æ',
                    solution: 'æ”¯ç‚¹ååŠ›: Ay=5kN, By=5kN\néƒ¨æè»¸åŠ›: N1=7.07kN(T), N2=7.07kN(T)'
                },
                {
                    id: 'truss_02',
                    title: 'ãƒ¯ãƒ¼ãƒ¬ãƒ³ãƒˆãƒ©ã‚¹',
                    difficulty: 'standard',
                    description: 'æ©‹æ¢ã§ã‚ˆãä½¿ç”¨ã•ã‚Œã‚‹å¹³è¡Œå¼¦ãƒˆãƒ©ã‚¹ã®è§£æ',
                    solution: 'ä¸Šå¼¦æã¯åœ§ç¸®ã€ä¸‹å¼¦æã¯å¼•å¼µã€æ–œæãƒ»å‚ç›´æã®è»¸åŠ›ã‚’ç®—å‡º'
                }
            ],
            beam: [
                {
                    id: 'beam_01',
                    title: 'å˜ç´”æ¢ - é›†ä¸­è·é‡',
                    difficulty: 'basic',
                    description: 'ä¸­å¤®ã«é›†ä¸­è·é‡ãŒä½œç”¨ã™ã‚‹å˜ç´”æ¢',
                    solution: 'Mmax = PL/4, Î´max = PLÂ³/(48EI)'
                },
                {
                    id: 'beam_02',
                    title: 'ç‰‡æŒã¡æ¢ - åˆ†å¸ƒè·é‡',
                    difficulty: 'standard',
                    description: 'ç­‰åˆ†å¸ƒè·é‡ãŒä½œç”¨ã™ã‚‹ç‰‡æŒã¡æ¢',
                    solution: 'Mmax = wLÂ²/2, Î´max = wLâ´/(8EI)'
                }
            ]
        };

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeTabs();
            initializeCanvases();
            loadMaterials();
            loadLearningContent();
            loadExamples();
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆææ–™è¨­å®š
            currentStructure.selectedMaterial = materialDatabase[0];
        });

        // ã‚¿ãƒ–æ©Ÿèƒ½
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ãƒ–ã‚’åˆ‡ã‚Šæ›¿ãˆ
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹åˆæœŸåŒ–
        function initializeCanvases() {
            const trussCanvas = document.getElementById('trussCanvas');
            const beamCanvas = document.getElementById('beamCanvas');
            
            if (trussCanvas) {
                trussCanvas.addEventListener('click', handleTrussCanvasClick);
                trussCanvas.addEventListener('mousemove', handleTrussCanvasHover);
                drawTrussGrid(trussCanvas);
            }
            
            if (beamCanvas) {
                drawBeamStructure();
            }

            // å¤‰å½¢å€ç‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
            const deformScale = document.getElementById('deformScale');
            if (deformScale) {
                deformScale.addEventListener('input', (e) => {
                    document.getElementById('deformScaleValue').textContent = e.target.value + 'x';
                    if (analysisResults) {
                        drawTrussResults();
                    }
                });
            }
        }

        // ãƒˆãƒ©ã‚¹æ§‹é€ ã®æç”»
        function drawTrussGrid(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ã‚°ãƒªãƒƒãƒ‰æç”»
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            drawTrussStructure();
        }

        function drawTrussStructure() {
            const canvas = document.getElementById('trussCanvas');
            const ctx = canvas.getContext('2d');
            
            // éƒ¨æã‚’æç”»
            currentStructure.elements.forEach((element, index) => {
                const node1 = currentStructure.nodes[element.node1];
                const node2 = currentStructure.nodes[element.node2];
                
                if (node1 && node2) {
                    ctx.beginPath();
                    ctx.moveTo(node1.x, node1.y);
                    ctx.lineTo(node2.x, node2.y);
                    
                    // å¿œåŠ›ã«ã‚ˆã‚‹è‰²åˆ†ã‘
                    if (analysisResults && analysisResults.elementStresses[index] !== undefined) {
                        const stress = analysisResults.elementStresses[index];
                        if (stress > 0) {
                            ctx.strokeStyle = '#dc3545'; // å¼•å¼µï¼ˆèµ¤ï¼‰
                        } else {
                            ctx.strokeStyle = '#28a745'; // åœ§ç¸®ï¼ˆç·‘ï¼‰
                        }
                        ctx.lineWidth = Math.max(2, Math.abs(stress) / 10);
                    } else {
                        ctx.strokeStyle = '#6c757d';
                        ctx.lineWidth = 2;
                    }
                    
                    ctx.stroke();
                    
                    // éƒ¨æç•ªå·è¡¨ç¤º
                    const midX = (node1.x + node2.x) / 2;
                    const midY = (node1.y + node2.y) / 2;
                    ctx.fillStyle = '#495057';
                    ctx.font = '12px Arial';
                    ctx.fillText(`E${index}`, midX + 5, midY - 5);
                }
            });
            
            // ç¯€ç‚¹ã‚’æç”»
            currentStructure.nodes.forEach((node, index) => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, 2 * Math.PI);
                
                // æ”¯æŒæ¡ä»¶ã«ã‚ˆã‚‹è‰²åˆ†ã‘
                const support = currentStructure.supports.find(s => s.node === index);
                if (support) {
                    ctx.fillStyle = '#ffc107'; // æ”¯æŒç‚¹ï¼ˆé»„ï¼‰
                } else {
                    ctx.fillStyle = '#007bff'; // è‡ªç”±ç¯€ç‚¹ï¼ˆé’ï¼‰
                }
                
                ctx.fill();
                ctx.strokeStyle = '#343a40';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç¯€ç‚¹ç•ªå·è¡¨ç¤º
                ctx.fillStyle = '#495057';
                ctx.font = '12px Arial';
                ctx.fillText(`N${index}`, node.x + 10, node.y - 10);
                
                // å¤‰ä½è¡¨ç¤º
                if (analysisResults && analysisResults.nodeDisplacements[index]) {
                    const disp = analysisResults.nodeDisplacements[index];
                    const scale = document.getElementById('deformScale').value / 10;
                    const dispX = disp.x * scale;
                    const dispY = disp.y * scale;
                    
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.x + dispX, node.y + dispY);
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // è·é‡ã‚’æç”»
            currentStructure.loads.forEach(load => {
                const node = currentStructure.nodes[load.node];
                if (node) {
                    drawLoadArrow(ctx, node.x, node.y, load.fx, load.fy);
                }
            });
        }

        function drawLoadArrow(ctx, x, y, fx, fy) {
            const scale = 0.1; // è·é‡è¡¨ç¤ºã‚¹ã‚±ãƒ¼ãƒ«
            const arrowX = fx * scale;
            const arrowY = fy * scale;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + arrowX, y + arrowY);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // çŸ¢å°ã®é ­
            const angle = Math.atan2(arrowY, arrowX);
            const headlen = 10;
            
            ctx.beginPath();
            ctx.moveTo(x + arrowX, y + arrowY);
            ctx.lineTo(x + arrowX - headlen * Math.cos(angle - Math.PI/6),
                      y + arrowY - headlen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(x + arrowX, y + arrowY);
            ctx.lineTo(x + arrowX - headlen * Math.cos(angle + Math.PI/6),
                      y + arrowY - headlen * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }

        // ãƒˆãƒ©ã‚¹è§£æé–¢æ•°
        function addNode() {
            // æ¬¡ã®ç©ºã„ã¦ã„ã‚‹ä½ç½®ã«ç¯€ç‚¹ã‚’è¿½åŠ 
            const canvas = document.getElementById('trussCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = 100 + (currentStructure.nodes.length % 8) * 80;
            const y = 200 + Math.floor(currentStructure.nodes.length / 8) * 80;
            
            currentStructure.nodes.push({x, y});
            drawTrussGrid(canvas);
        }

        function addElement() {
            if (currentStructure.nodes.length < 2) {
                showMessage('éƒ¨æã‚’è¿½åŠ ã™ã‚‹ã«ã¯å°‘ãªãã¨ã‚‚2ã¤ã®ç¯€ç‚¹ãŒå¿…è¦ã§ã™ã€‚', 'error');
                return;
            }
            
            // æœ€å¾Œã®2ã¤ã®ç¯€ç‚¹ã‚’æ¥ç¶š
            const nodeCount = currentStructure.nodes.length;
            currentStructure.elements.push({
                node1: nodeCount - 2,
                node2: nodeCount - 1,
                area: 0.01, // mÂ²
                material: currentStructure.selectedMaterial
            });
            
            drawTrussGrid(document.getElementById('trussCanvas'));
        }

        function setSupport() {
            if (currentStructure.nodes.length === 0) {
                showMessage('æ”¯æŒæ¡ä»¶ã‚’è¨­å®šã™ã‚‹ã«ã¯ç¯€ç‚¹ãŒå¿…è¦ã§ã™ã€‚', 'error');
                return;
            }
            
            // æœ€åˆã®ç¯€ç‚¹ã‚’ãƒ”ãƒ³æ”¯æŒã€2ç•ªç›®ã‚’ãƒ­ãƒ¼ãƒ©ãƒ¼æ”¯æŒã«è¨­å®š
            currentStructure.supports = [
                {node: 0, type: 'pin', ux: true, uy: true},
                {node: 1, type: 'roller', ux: false, uy: true}
            ];
            
            drawTrussGrid(document.getElementById('trussCanvas'));
        }

        function setLoad() {
            if (currentStructure.nodes.length === 0) {
                showMessage('è·é‡ã‚’è¨­å®šã™ã‚‹ã«ã¯ç¯€ç‚¹ãŒå¿…è¦ã§ã™ã€‚', 'error');
                return;
            }
            
            // æœ€å¾Œã®ç¯€ç‚¹ã«ä¸‹å‘ãè·é‡ã‚’è¨­å®š
            const lastNode = currentStructure.nodes.length - 1;
            currentStructure.loads.push({
                node: lastNode,
                fx: 0,
                fy: -10000 // N
            });
            
            drawTrussGrid(document.getElementById('trussCanvas'));
        }

        function analyzeStructure() {
            if (currentStructure.nodes.length < 2 || currentStructure.elements.length === 0) {
                showMessage('è§£æã«ã¯å°‘ãªãã¨ã‚‚2ã¤ã®ç¯€ç‚¹ã¨1ã¤ã®éƒ¨æãŒå¿…è¦ã§ã™ã€‚', 'error');
                return;
            }
            
            if (currentStructure.supports.length === 0) {
                showMessage('æ”¯æŒæ¡ä»¶ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            showAnalysisProgress();
            
            setTimeout(() => {
                try {
                    analysisResults = performStructuralAnalysis();
                    updateAnalysisResults();
                    drawTrussResults();
                    showMessage('è§£æãŒå®Œäº†ã—ã¾ã—ãŸã€‚', 'success');
                } catch (error) {
                    showMessage('è§£æã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
                hideAnalysisProgress();
            }, 1000);
        }

        function performStructuralAnalysis() {
            const nodeCount = currentStructure.nodes.length;
            const dofCount = nodeCount * 2; // 2 DOF per node
            
            // å…¨ä½“å‰›æ€§ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã®åˆæœŸåŒ–
            const K = Array(dofCount).fill().map(() => Array(dofCount).fill(0));
            
            // éƒ¨æå‰›æ€§ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã®çµ„ã¿ç«‹ã¦
            currentStructure.elements.forEach(element => {
                const node1 = currentStructure.nodes[element.node1];
                const node2 = currentStructure.nodes[element.node2];
                
                const L = Math.sqrt(Math.pow(node2.x - node1.x, 2) + Math.pow(node2.y - node1.y, 2)) / 1000; // mm to m
                const cos = (node2.x - node1.x) / (L * 1000);
                const sin = (node2.y - node1.y) / (L * 1000);
                
                const E = element.material.E * 1e6; // MPa to Pa
                const A = element.area; // mÂ²
                const k = E * A / L;
                
                // éƒ¨æåº§æ¨™ç³»ã‹ã‚‰å…¨ä½“åº§æ¨™ç³»ã¸ã®å¤‰æ›ãƒãƒˆãƒªãƒƒã‚¯ã‚¹
                const T = [
                    [cos, sin, 0, 0],
                    [-sin, cos, 0, 0],
                    [0, 0, cos, sin],
                    [0, 0, -sin, cos]
                ];
                
                // éƒ¨æå‰›æ€§ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ï¼ˆå…¨ä½“åº§æ¨™ç³»ï¼‰
                const ke = [
                    [k * cos * cos, k * cos * sin, -k * cos * cos, -k * cos * sin],
                    [k * cos * sin, k * sin * sin, -k * cos * sin, -k * sin * sin],
                    [-k * cos * cos, -k * cos * sin, k * cos * cos, k * cos * sin],
                    [-k * cos * sin, -k * sin * sin, k * cos * sin, k * sin * sin]
                ];
                
                // å…¨ä½“å‰›æ€§ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã¸ã®çµ„ã¿è¾¼ã¿
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        K[element.node1 * 2 + i][element.node1 * 2 + j] += ke[i][j];
                        K[element.node1 * 2 + i][element.node2 * 2 + j] += ke[i][j + 2];
                        K[element.node2 * 2 + i][element.node1 * 2 + j] += ke[i + 2][j];
                        K[element.node2 * 2 + i][element.node2 * 2 + j] += ke[i + 2][j + 2];
                    }
                }
            });
            
            // è·é‡ãƒ™ã‚¯ãƒˆãƒ«ã®çµ„ã¿ç«‹ã¦
            const F = Array(dofCount).fill(0);
            currentStructure.loads.forEach(load => {
                F[load.node * 2] += load.fx;
                F[load.node * 2 + 1] += load.fy;
            });
            
            // å¢ƒç•Œæ¡ä»¶ã®é©ç”¨
            currentStructure.supports.forEach(support => {
                if (support.ux) {
                    // Xæ–¹å‘æ‹˜æŸ
                    const dof = support.node * 2;
                    for (let i = 0; i < dofCount; i++) {
                        K[dof][i] = 0;
                        K[i][dof] = 0;
                    }
                    K[dof][dof] = 1;
                    F[dof] = 0;
                }
                if (support.uy) {
                    // Yæ–¹å‘æ‹˜æŸ
                    const dof = support.node * 2 + 1;
                    for (let i = 0; i < dofCount; i++) {
                        K[dof][i] = 0;
                        K[i][dof] = 0;
                    }
                    K[dof][dof] = 1;
                    F[dof] = 0;
                }
            });
            
            // é€£ç«‹æ–¹ç¨‹å¼ã®æ±‚è§£ï¼ˆã‚¬ã‚¦ã‚¹æ¶ˆå»æ³•ï¼‰
            const displacements = solveLinearSystem(K, F);
            
            // ç¯€ç‚¹å¤‰ä½ã®æ•´ç†
            const nodeDisplacements = [];
            for (let i = 0; i < nodeCount; i++) {
                nodeDisplacements.push({
                    x: displacements[i * 2] * 1000,     // m to mm
                    y: displacements[i * 2 + 1] * 1000  // m to mm
                });
            }
            
            // éƒ¨æå¿œåŠ›ã®è¨ˆç®—
            const elementStresses = [];
            currentStructure.elements.forEach((element, index) => {
                const node1 = currentStructure.nodes[element.node1];
                const node2 = currentStructure.nodes[element.node2];
                
                const L = Math.sqrt(Math.pow(node2.x - node1.x, 2) + Math.pow(node2.y - node1.y, 2)) / 1000;
                const cos = (node2.x - node1.x) / (L * 1000);
                const sin = (node2.y - node1.y) / (L * 1000);
                
                const u1x = displacements[element.node1 * 2];
                const u1y = displacements[element.node1 * 2 + 1];
                const u2x = displacements[element.node2 * 2];
                const u2y = displacements[element.node2 * 2 + 1];
                
                const deltaL = cos * (u2x - u1x) + sin * (u2y - u1y);
                const strain = deltaL / L;
                const stress = element.material.E * 1e6 * strain / 1e6; // MPa
                
                elementStresses.push(stress);
            });
            
            return {
                nodeDisplacements,
                elementStresses,
                maxStress: Math.max(...elementStresses.map(Math.abs)),
                maxDisplacement: Math.max(...nodeDisplacements.map(d => Math.sqrt(d.x*d.x + d.y*d.y)))
            };
        }

        function solveLinearSystem(A, b) {
            const n = A.length;
            const x = [...b];
            
            // ã‚¬ã‚¦ã‚¹æ¶ˆå»æ³•
            for (let i = 0; i < n; i++) {
                // ãƒ”ãƒœãƒƒãƒˆé¸æŠ
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
                        maxRow = k;
                    }
                }
                
                // è¡Œäº¤æ›
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [x[i], x[maxRow]] = [x[maxRow], x[i]];
                
                // å‰é€²æ¶ˆå»
                for (let k = i + 1; k < n; k++) {
                    const factor = A[k][i] / A[i][i];
                    for (let j = i; j < n; j++) {
                        A[k][j] -= factor * A[i][j];
                    }
                    x[k] -= factor * x[i];
                }
            }
            
            // å¾Œé€€ä»£å…¥
            for (let i = n - 1; i >= 0; i--) {
                for (let k = i + 1; k < n; k++) {
                    x[i] -= A[i][k] * x[k];
                }
                x[i] /= A[i][i];
            }
            
            return x;
        }

        function drawTrussResults() {
            drawTrussStructure();
        }

        function updateAnalysisResults() {
            if (!analysisResults) return;
            
            document.getElementById('maxStress').textContent = 
                analysisResults.maxStress.toFixed(2);
            document.getElementById('maxDisp').textContent = 
                analysisResults.maxDisplacement.toFixed(3);
            
            const safetyFactor = currentStructure.selectedMaterial.fy / analysisResults.maxStress;
            document.getElementById('safetyFactor').textContent = 
                safetyFactor.toFixed(2);
            
            // ç·é‡é‡è¨ˆç®—
            let totalWeight = 0;
            currentStructure.elements.forEach(element => {
                const node1 = currentStructure.nodes[element.node1];
                const node2 = currentStructure.nodes[element.node2];
                const length = Math.sqrt(Math.pow(node2.x - node1.x, 2) + Math.pow(node2.y - node1.y, 2)) / 1000;
                totalWeight += element.area * length * element.material.density;
            });
            document.getElementById('totalWeight').textContent = totalWeight.toFixed(1);
        }

        function clearStructure() {
            currentStructure = {
                nodes: [],
                elements: [],
                supports: [],
                loads: [],
                selectedMaterial: materialDatabase[0]
            };
            analysisResults = null;
            
            drawTrussGrid(document.getElementById('trussCanvas'));
            
            // çµæœã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('maxStress').textContent = '0';
            document.getElementById('maxDisp').textContent = '0';
            document.getElementById('safetyFactor').textContent = 'âˆ';
            document.getElementById('totalWeight').textContent = '0';
        }

        // æ¢è§£æé–¢æ•°
        function drawBeamStructure() {
            const canvas = document.getElementById('beamCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const beamLength = currentBeam.length;
            const scale = 600 / beamLength; // ãƒ”ã‚¯ã‚»ãƒ«/m
            const beamY = 200;
            const beamStartX = 100;
            const beamEndX = beamStartX + beamLength * scale;
            
            // æ¢ã®æç”»
            ctx.strokeStyle = '#495057';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(beamStartX, beamY);
            ctx.lineTo(beamEndX, beamY);
            ctx.stroke();
            
            // æ”¯æŒæ¡ä»¶ã®æç”»
            drawSupports(ctx, beamStartX, beamEndX, beamY);
            
            // è·é‡ã®æç”»
            currentBeam.loads.forEach(load => {
                const x = beamStartX + load.position * scale;
                drawBeamLoad(ctx, x, beamY, load);
            });
            
            // ã‚¹ã‚±ãƒ¼ãƒ«è¡¨ç¤º
            ctx.fillStyle = '#495057';
            ctx.font = '12px Arial';
            ctx.fillText(`æ¢é•·: ${beamLength}m`, beamStartX, beamY + 50);
        }

        function drawSupports(ctx, startX, endX, y) {
            const supportType = currentBeam.support;
            
            if (supportType === 'simple') {
                // å˜ç´”æ¢ï¼ˆãƒ”ãƒ³ + ãƒ­ãƒ¼ãƒ©ãƒ¼ï¼‰
                drawPinSupport(ctx, startX, y);
                drawRollerSupport(ctx, endX, y);
            } else if (supportType === 'cantilever') {
                // ç‰‡æŒã¡æ¢ï¼ˆå›ºå®šæ”¯æŒï¼‰
                drawFixedSupport(ctx, startX, y);
            } else if (supportType === 'fixed') {
                // ä¸¡ç«¯å›ºå®šæ¢
                drawFixedSupport(ctx, startX, y);
                drawFixedSupport(ctx, endX, y);
            }
        }

        function drawPinSupport(ctx, x, y) {
            ctx.beginPath();
            ctx.moveTo(x - 15, y + 10);
            ctx.lineTo(x, y);
            ctx.lineTo(x + 15, y + 10);
            ctx.closePath();
            ctx.fillStyle = '#ffc107';
            ctx.fill();
            ctx.strokeStyle = '#343a40';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawRollerSupport(ctx, x, y) {
            ctx.beginPath();
            ctx.arc(x, y + 15, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#ffc107';
            ctx.fill();
            ctx.strokeStyle = '#343a40';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ä¸‰è§’å½¢
            ctx.beginPath();
            ctx.moveTo(x - 12, y + 7);
            ctx.lineTo(x, y);
            ctx.lineTo(x + 12, y + 7);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function drawFixedSupport(ctx, x, y) {
            ctx.fillStyle = '#6c757d';
            ctx.fillRect(x - 3, y - 20, 6, 40);
            
            // ãƒãƒƒãƒãƒ³ã‚°
            ctx.strokeStyle = '#343a40';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 15; i += 5) {
                ctx.beginPath();
                ctx.moveTo(x - 3, y + i);
                ctx.lineTo(x - 10, y + i - 7);
                ctx.stroke();
            }
        }

        function drawBeamLoad(ctx, x, y, load) {
            if (load.type === 'point') {
                // é›†ä¸­è·é‡
                drawLoadArrow(ctx, x, y - 50, 0, load.value * 5);
                ctx.fillStyle = '#e74c3c';
                ctx.font = '12px Arial';
                ctx.fillText(`${load.value}kN`, x + 5, y - 60);
            } else if (load.type === 'distributed') {
                // åˆ†å¸ƒè·é‡
                const scale = 600 / currentBeam.length;
                const startX = x;
                const endX = x + (load.endPosition - load.position) * scale;
                
                for (let i = startX; i <= endX; i += 20) {
                    drawLoadArrow(ctx, i, y - 30, 0, load.value * 2);
                }
                
                ctx.fillStyle = '#e74c3c';
                ctx.font = '12px Arial';
                ctx.fillText(`${load.value}kN/m`, startX, y - 40);
            }
        }

        function addBeamLoad() {
            const loadType = document.getElementById('loadType').value;
            const loadValue = parseFloat(document.getElementById('loadValue').value);
            const loadPosition = parseFloat(document.getElementById('loadPosition').value);
            
            if (loadPosition > currentBeam.length) {
                showMessage('è·é‡ä½ç½®ãŒæ¢é•·ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚', 'error');
                return;
            }
            
            const load = {
                type: loadType,
                value: loadValue,
                position: loadPosition
            };
            
            if (loadType === 'distributed') {
                load.endPosition = Math.min(loadPosition + 2, currentBeam.length);
            }
            
            currentBeam.loads.push(load);
            drawBeamStructure();
        }

        function analyzeBeam() {
            if (currentBeam.loads.length === 0) {
                showMessage('è·é‡ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            showAnalysisProgress();
            
            setTimeout(() => {
                try {
                    const results = performBeamAnalysis();
                    drawBeamDiagrams(results);
                    showMessage('æ¢è§£æãŒå®Œäº†ã—ã¾ã—ãŸã€‚', 'success');
                } catch (error) {
                    showMessage('è§£æã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
                hideAnalysisProgress();
            }, 1000);
        }

        function performBeamAnalysis() {
            const length = currentBeam.length;
            const numPoints = 101; // è§£æç‚¹æ•°
            const dx = length / (numPoints - 1);
            
            const x = [];
            const M = []; // æ›²ã’ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ
            const Q = []; // ã›ã‚“æ–­åŠ›
            const delta = []; // ãŸã‚ã¿
            
            for (let i = 0; i < numPoints; i++) {
                x.push(i * dx);
                M.push(0);
                Q.push(0);
                delta.push(0);
            }
            
            // è·é‡ã«ã‚ˆã‚‹å½±éŸ¿ã‚’è¨ˆç®—
            currentBeam.loads.forEach(load => {
                if (load.type === 'point') {
                    // é›†ä¸­è·é‡
                    calculatePointLoadEffects(x, M, Q, delta, load, length);
                } else if (load.type === 'distributed') {
                    // åˆ†å¸ƒè·é‡
                    calculateDistributedLoadEffects(x, M, Q, delta, load, length);
                }
            });
            
            return { x, M, Q, delta };
        }

        function calculatePointLoadEffects(x, M, Q, delta, load, L) {
            const P = load.value * 1000; // kN to N
            const a = load.position;
            const b = L - a;
            
            // æ”¯æŒæ¡ä»¶ã«å¿œã˜ãŸè¨ˆç®—
            if (currentBeam.support === 'simple') {
                // å˜ç´”æ¢
                const R1 = P * b / L;
                const R2 = P * a / L;
                
                for (let i = 0; i < x.length; i++) {
                    if (x[i] <= a) {
                        Q[i] += R1;
                        M[i] += R1 * x[i];
                    } else {
                        Q[i] += R1 - P;
                        M[i] += R1 * x[i] - P * (x[i] - a);
                    }
                }
            } else if (currentBeam.support === 'cantilever') {
                // ç‰‡æŒã¡æ¢
                for (let i = 0; i < x.length; i++) {
                    if (x[i] >= a) {
                        Q[i] -= P;
                        M[i] -= P * (x[i] - a);
                    }
                }
            }
        }

        function calculateDistributedLoadEffects(x, M, Q, delta, load, L) {
            const w = load.value * 1000; // kN/m to N/m
            const start = load.position;
            const end = load.endPosition || start + 1;
            
            if (currentBeam.support === 'simple') {
                // å˜ç´”æ¢ã®åˆ†å¸ƒè·é‡
                const a = start;
                const c = end - start;
                const W = w * c; // ç·è·é‡
                const R1 = W * (L - a - c/2) / L;
                const R2 = W * (a + c/2) / L;
                
                for (let i = 0; i < x.length; i++) {
                    if (x[i] <= a) {
                        Q[i] += R1;
                        M[i] += R1 * x[i];
                    } else if (x[i] <= end) {
                        const loadLength = x[i] - a;
                        Q[i] += R1 - w * loadLength;
                        M[i] += R1 * x[i] - w * loadLength * loadLength / 2;
                    } else {
                        Q[i] += R1 - W;
                        M[i] += R1 * x[i] - W * (x[i] - a - c/2);
                    }
                }
            }
        }

        function drawBeamDiagrams(results) {
            drawDiagram('sfdCanvas', results.x, results.Q, 'ã›ã‚“æ–­åŠ› (kN)', '#28a745');
            drawDiagram('bmdCanvas', results.x, results.M, 'æ›²ã’ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ (kNÂ·m)', '#dc3545');
            drawDiagram('deflectionCanvas', results.x, results.delta, 'ãŸã‚ã¿ (mm)', '#007bff');
        }

        function drawDiagram(canvasId, x, y, label, color) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è»¸ã¨ã‚°ãƒªãƒƒãƒ‰
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 1;
            
            // åŸºæº–ç·š
            const zeroY = canvas.height / 2;
            ctx.beginPath();
            ctx.moveTo(50, zeroY);
            ctx.lineTo(canvas.width - 50, zeroY);
            ctx.stroke();
            
            // ãƒ‡ãƒ¼ã‚¿ã®æç”»
            if (y.length === 0) return;
            
            const maxX = Math.max(...x);
            const maxY = Math.max(...y.map(Math.abs));
            const scaleX = (canvas.width - 100) / maxX;
            const scaleY = maxY > 0 ? (canvas.height - 40) / 2 / maxY : 1;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < x.length; i++) {
                const px = 50 + x[i] * scaleX;
                const py = zeroY - y[i] * scaleY;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            
            ctx.stroke();
            
            // ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#495057';
            ctx.font = '12px Arial';
            ctx.fillText(label, 10, 20);
            
            // æœ€å¤§å€¤ãƒ»æœ€å°å€¤ã®è¡¨ç¤º
            const maxVal = Math.max(...y);
            const minVal = Math.min(...y);
            ctx.fillText(`Max: ${(maxVal/1000).toFixed(2)}`, canvas.width - 100, 20);
            ctx.fillText(`Min: ${(minVal/1000).toFixed(2)}`, canvas.width - 100, 35);
        }

        function clearBeam() {
            currentBeam.loads = [];
            drawBeamStructure();
            
            // å›³è¡¨ã‚’ã‚¯ãƒªã‚¢
            ['sfdCanvas', 'bmdCanvas', 'deflectionCanvas'].forEach(canvasId => {
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });
        }

        // ææ–™ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢æ•°
        function loadMaterials() {
            const container = document.getElementById('materialDatabase');
            if (!container) return;
            
            container.innerHTML = '';
            
            materialDatabase.forEach(material => {
                const card = document.createElement('div');
                card.className = 'material-card';
                if (currentStructure.selectedMaterial && currentStructure.selectedMaterial.id === material.id) {
                    card.classList.add('selected');
                }
                
                card.innerHTML = `
                    <h4>${material.name}</h4>
                    <p><strong>ã‚«ãƒ†ã‚´ãƒª:</strong> ${getCategoryName(material.category)}</p>
                    <p><strong>å¼¾æ€§ä¿‚æ•°:</strong> ${material.E.toLocaleString()} MPa</p>
                    <p><strong>å¯†åº¦:</strong> ${material.density} kg/mÂ³</p>
                `;
                
                card.addEventListener('click', () => selectMaterial(material));
                container.appendChild(card);
            });
        }

        function getCategoryName(category) {
            const names = {
                steel: 'é‹¼æ',
                concrete: 'ã‚³ãƒ³ã‚¯ãƒªãƒ¼ãƒˆ',
                wood: 'æœ¨æ',
                aluminum: 'ã‚¢ãƒ«ãƒŸãƒ‹ã‚¦ãƒ '
            };
            return names[category] || category;
        }

        function selectMaterial(material) {
            currentStructure.selectedMaterial = material;
            loadMaterials(); // å†æç”»
            
            // è©³ç´°è¡¨ç¤º
            const details = document.getElementById('materialDetails');
            details.innerHTML = `
                <h4>${material.name}</h4>
                <div class="results-grid">
                    <div class="result-card">
                        <h4>å¼¾æ€§ä¿‚æ•° (E)</h4>
                        <div class="result-value">${material.E.toLocaleString()}<span class="result-unit">MPa</span></div>
                    </div>
                    <div class="result-card">
                        <h4>é™ä¼å¼·åº¦</h4>
                        <div class="result-value">${material.fy || material.fc || material.fb || '-'}<span class="result-unit">MPa</span></div>
                    </div>
                    <div class="result-card">
                        <h4>å¯†åº¦</h4>
                        <div class="result-value">${material.density}<span class="result-unit">kg/mÂ³</span></div>
                    </div>
                    <div class="result-card">
                        <h4>ãƒã‚¢ã‚½ãƒ³æ¯”</h4>
                        <div class="result-value">${material.poisson}<span class="result-unit">-</span></div>
                    </div>
                </div>
            `;
        }

        function filterMaterials() {
            const category = document.getElementById('materialCategory').value;
            const search = document.getElementById('materialSearch').value.toLowerCase();
            
            const filtered = materialDatabase.filter(material => {
                const categoryMatch = category === 'all' || material.category === category;
                const searchMatch = material.name.toLowerCase().includes(search);
                return categoryMatch && searchMatch;
            });
            
            const container = document.getElementById('materialDatabase');
            container.innerHTML = '';
            
            filtered.forEach(material => {
                const card = document.createElement('div');
                card.className = 'material-card';
                if (currentStructure.selectedMaterial && currentStructure.selectedMaterial.id === material.id) {
                    card.classList.add('selected');
                }
                
                card.innerHTML = `
                    <h4>${material.name}</h4>
                    <p><strong>ã‚«ãƒ†ã‚´ãƒª:</strong> ${getCategoryName(material.category)}</p>
                    <p><strong>å¼¾æ€§ä¿‚æ•°:</strong> ${material.E.toLocaleString()} MPa</p>
                    <p><strong>å¯†åº¦:</strong> ${material.density} kg/mÂ³</p>
                `;
                
                card.addEventListener('click', () => selectMaterial(material));
                container.appendChild(card);
            });
        }

        // å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰é–¢æ•°
        function loadLearningContent() {
            const topic = document.getElementById('learningTopic')?.value || 'basics';
            const container = document.getElementById('learningContent');
            
            if (container && learningContent[topic]) {
                container.innerHTML = `
                    <div class="chart-container">
                        <h3>${learningContent[topic].title}</h3>
                        ${learningContent[topic].content}
                    </div>
                `;
            }
        }

        // ä¾‹é¡Œé›†é–¢æ•°
        function loadExamples() {
            const category = document.getElementById('exampleCategory')?.value || 'truss';
            const container = document.getElementById('examplesList');
            
            if (container && exampleProblems[category]) {
                container.innerHTML = '';
                
                exampleProblems[category].forEach(problem => {
                    const card = document.createElement('div');
                    card.className = 'chart-container';
                    card.innerHTML = `
                        <h4>${problem.title}</h4>
                        <p><strong>é›£æ˜“åº¦:</strong> ${problem.difficulty}</p>
                        <p><strong>å•é¡Œ:</strong> ${problem.description}</p>
                        <details>
                            <summary>è§£ç­”ã‚’è¡¨ç¤º</summary>
                            <div class="calculation-steps">
                                ${problem.solution}
                            </div>
                        </details>
                        <button class="btn" onclick="loadExampleProblem('${problem.id}')">ã“ã®å•é¡Œã‚’èª­ã¿è¾¼ã¿</button>
                    `;
                    container.appendChild(card);
                });
            }
        }

        function loadExampleProblem(problemId) {
            // ä¾‹é¡Œã‚’ç¾åœ¨ã®è§£æãƒ¢ãƒ‡ãƒ«ã«èª­ã¿è¾¼ã¿
            if (problemId === 'truss_01') {
                // åŸºæœ¬ãƒˆãƒ©ã‚¹å•é¡Œã‚’èª­ã¿è¾¼ã¿
                clearStructure();
                currentStructure.nodes = [
                    {x: 100, y: 300},
                    {x: 300, y: 300},
                    {x: 200, y: 200}
                ];
                currentStructure.elements = [
                    {node1: 0, node2: 2, area: 0.01, material: materialDatabase[0]},
                    {node1: 1, node2: 2, area: 0.01, material: materialDatabase[0]}
                ];
                currentStructure.supports = [
                    {node: 0, type: 'pin', ux: true, uy: true},
                    {node: 1, type: 'roller', ux: false, uy: true}
                ];
                currentStructure.loads = [
                    {node: 2, fx: 0, fy: -10000}
                ];
                
                drawTrussGrid(document.getElementById('trussCanvas'));
                
                // ãƒˆãƒ©ã‚¹è§£æã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆ
                document.querySelector('[data-tab="truss"]').click();
            }
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function showAnalysisProgress() {
            isAnalyzing = true;
            const progressBar = document.getElementById('progressBar');
            let progress = 0;
            
            const interval = setInterval(() => {
                progress += 10;
                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }
                
                if (progress >= 100 || !isAnalyzing) {
                    clearInterval(interval);
                }
            }, 100);
        }

        function hideAnalysisProgress() {
            isAnalyzing = false;
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = '0%';
            }
        }

        function showMessage(message, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = message;
            
            const container = document.querySelector('.main-content');
            container.insertBefore(messageDiv, container.firstChild);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 5000);
        }

        function generateReport() {
            // ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆæ©Ÿèƒ½ï¼ˆç°¡æ˜“ç‰ˆï¼‰
            const reportWindow = window.open('', '_blank');
            reportWindow.document.write(`
                <html>
                <head>
                    <title>æ§‹é€ è§£æãƒ¬ãƒãƒ¼ãƒˆ</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 40px; }
                        h1, h2 { color: #333; }
                        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                    </style>
                </head>
                <body>
                    <h1>æ§‹é€ è§£æãƒ¬ãƒãƒ¼ãƒˆ</h1>
                    <h2>è§£ææ¡ä»¶</h2>
                    <p>æ¢é•·: ${currentBeam.length}m</p>
                    <p>æ”¯æŒæ¡ä»¶: ${currentBeam.support}</p>
                    <p>è·é‡æ•°: ${currentBeam.loads.length}</p>
                    
                    <h2>è§£æçµæœ</h2>
                    <p>ã“ã®ãƒ¬ãƒãƒ¼ãƒˆã¯æ§‹é€ åŠ›å­¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚</p>
                    
                    <h2>çµè«–</h2>
                    <p>è¨­è¨ˆæ¡ä»¶ã‚’æº€è¶³ã—ã¦ã„ã¾ã™ã€‚</p>
                </body>
                </html>
            `);
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
        function handleTrussCanvasClick(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
            const snapX = Math.round(x / 40) * 40;
            const snapY = Math.round(y / 40) * 40;
            
            // æ—¢å­˜ã®ç¯€ç‚¹ã¨é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const existingNode = currentStructure.nodes.find(node => 
                Math.abs(node.x - snapX) < 20 && Math.abs(node.y - snapY) < 20
            );
            
            if (!existingNode) {
                currentStructure.nodes.push({x: snapX, y: snapY});
                drawTrussGrid(canvas);
            }
        }

        function handleTrussCanvasHover(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // ç¯€ç‚¹ã‚„ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã®æƒ…å ±è¡¨ç¤º
            const nodeInfo = document.getElementById('nodeInfo');
            const elementInfo = document.getElementById('elementInfo');
            
            // è¿‘ãã®ç¯€ç‚¹ã‚’æ¤œç´¢
            const nearbyNode = currentStructure.nodes.findIndex(node => 
                Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2) < 15
            );
            
            if (nearbyNode !== -1) {
                nodeInfo.style.display = 'block';
                nodeInfo.style.left = (rect.left + x + 10) + 'px';
                nodeInfo.style.top = (rect.top + y - 30) + 'px';
                
                let info = `ç¯€ç‚¹ ${nearbyNode}`;
                if (analysisResults && analysisResults.nodeDisplacements[nearbyNode]) {
                    const disp = analysisResults.nodeDisplacements[nearbyNode];
                    info += `<br>å¤‰ä½: (${disp.x.toFixed(2)}, ${disp.y.toFixed(2)})mm`;
                }
                nodeInfo.innerHTML = info;
            } else {
                nodeInfo.style.display = 'none';
            }
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ
        window.addEventListener('resize', debounce(() => {
            const canvases = document.querySelectorAll('canvas');
            canvases.forEach(canvas => {
                if (canvas.id === 'trussCanvas') {
                    drawTrussGrid(canvas);
                } else if (canvas.id === 'beamCanvas') {
                    drawBeamStructure();
                }
            });
        }, 250));

        // ãƒ‡ãƒ¢æ©Ÿèƒ½
        function demoBasics() {
            const canvas = document.getElementById('basicsDemo');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // åŠ›ã®é‡£ã‚Šåˆã„ãƒ‡ãƒ¢
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            
            // æ°´å¹³åŠ›
            ctx.beginPath();
            ctx.moveTo(200, 100);
            ctx.lineTo(150, 100);
            ctx.stroke();
            drawArrowHead(ctx, 150, 100, Math.PI, '#007bff');
            
            ctx.beginPath();
            ctx.moveTo(200, 100);
            ctx.lineTo(250, 100);
            ctx.stroke();
            drawArrowHead(ctx, 250, 100, 0, '#007bff');
            
            // ä¸­å¿ƒç‚¹
            ctx.beginPath();
            ctx.arc(200, 100, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#dc3545';
            ctx.fill();
            
            // ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#495057';
            ctx.font = '12px Arial';
            ctx.fillText('F1', 130, 95);
            ctx.fillText('F2', 255, 95);
            ctx.fillText('Î£F = 0', 180, 130);
        }

        function drawArrowHead(ctx, x, y, angle, color) {
            const headlen = 8;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - headlen * Math.cos(angle - Math.PI/6), y - headlen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x - headlen * Math.cos(angle + Math.PI/6), y - headlen * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fill();
        }

        // å“è³ªä¿è¨¼ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        window.addEventListener('error', function(event) {
            console.error('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:', event.error);
            showMessage('äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚', 'error');
        });

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
        let performanceMetrics = {
            analysisTime: 0,
            renderTime: 0,
            lastAnalysis: null
        };

        function measurePerformance(operation, func) {
            const start = performance.now();
            const result = func();
            const end = performance.now();
            
            performanceMetrics[operation + 'Time'] = end - start;
            performanceMetrics.lastAnalysis = new Date();
            
            return result;
        }

        // è‡ªå‹•ä¿å­˜æ©Ÿèƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        function autoSave() {
            const data = {
                structure: currentStructure,
                beam: currentBeam,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem('structuralAnalysisAutoSave', JSON.stringify(data));
            } catch (e) {
                console.warn('è‡ªå‹•ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ:', e);
            }
        }

        function autoLoad() {
            try {
                const saved = localStorage.getItem('structuralAnalysisAutoSave');
                if (saved) {
                    const data = JSON.parse(saved);
                    // å¿…è¦ã«å¿œã˜ã¦å¾©å…ƒãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
                }
            } catch (e) {
                console.warn('è‡ªå‹•èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', e);
            }
        }

        // å®šæœŸçš„ãªè‡ªå‹•ä¿å­˜
        setInterval(autoSave, 30000); // 30ç§’ã”ã¨
    </script>
</body>
</html>