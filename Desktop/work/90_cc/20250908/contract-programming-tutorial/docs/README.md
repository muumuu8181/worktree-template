# 契約プログラミング (Contract Programming) チュートリアル

## 概要

契約プログラミング（Design by Contract）は、ソフトウェアの信頼性を高めるための手法です。
関数やメソッドの「契約」を明示的に定義し、実行時にその契約が守られていることを検証します。

## 契約プログラミングの3つの基本要素

### 1. 事前条件 (Precondition)
- 関数が呼び出される**前**に満たされるべき条件
- 呼び出し側の責任
- 例：引数が正しい型である、値が有効範囲内にある

### 2. 事後条件 (Postcondition)
- 関数が終了する**時**に保証される条件
- 実装側の責任
- 例：戻り値が期待される形式である、状態が正しく更新されている

### 3. 不変条件 (Invariant)
- オブジェクトが**常に**保つべき条件
- クラスの整合性を保証
- 例：カウンターが負の値にならない、リストのサイズが一定範囲内

## サンプルコードの実行方法

### Python版
```bash
python hello_contract.py
```

### JavaScript版
```bash
node hello_contract.js
```

## 実行結果の例

両方のプログラムは以下のような動作をします：

1. **正常な使用例**: "World"という名前で挨拶
2. **契約違反の例 - 空文字列**: 空文字列を渡して事前条件違反
3. **契約違反の例 - 型違い**: 数値を渡して事前条件違反
4. **複数回の呼び出し**: 正常な使い方で複数回実行

## 契約プログラミングのメリット

1. **バグの早期発見**: 契約違反は即座に検出される
2. **ドキュメントとしての役割**: コードが自己文書化される
3. **責任の明確化**: 誰が何を保証すべきかが明確になる
4. **テストの補完**: 実行時に常に検証が行われる

## 実装の違い

### Python版
- `assert`文を使用してシンプルに実装
- AssertionErrorで契約違反を通知

### JavaScript版
- カスタムエラークラス（ContractError）を定義
- より詳細なエラーメッセージを提供

## 次のステップ

このHello Worldレベルの例を理解したら、以下のような拡張を試してみてください：

1. より複雑な事前条件・事後条件の実装
2. クラス階層での不変条件の継承
3. 契約の有効化/無効化の切り替え機能
4. パフォーマンスへの影響の測定