<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ©Ÿæ¢°å­¦ç¿’ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å¯è¦–åŒ–ãƒ„ãƒ¼ãƒ«</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: radial-gradient(circle at center, #0a0a0a, #1a1a2e, #16213e, #8b008b);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 420px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            padding: 25px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }
        
        .main-canvas {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e);
        }
        
        h1 {
            font-size: 1.3em;
            margin-bottom: 25px;
            background: linear-gradient(45deg, #ff1493, #00bfff, #32cd32, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }
        
        .control-section {
            margin-bottom: 20px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 20, 147, 0.2);
        }
        
        .control-section h3 {
            color: #ff1493;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        label {
            display: block;
            margin: 8px 0 4px;
            color: #ccc;
            font-size: 0.9em;
        }
        
        select, input, button, textarea {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9em;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        button {
            background: linear-gradient(45deg, #ff1493, #00bfff);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 12px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 20, 147, 0.4);
        }
        
        .algorithm-types {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .algo-btn {
            padding: 8px;
            font-size: 0.8em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 20, 147, 0.3);
            color: #fff;
            text-align: center;
        }
        
        .algo-btn:hover {
            background: rgba(255, 20, 147, 0.2);
        }
        
        .algo-btn.active {
            background: rgba(255, 20, 147, 0.4);
            border-color: #ff1493;
        }
        
        .parameter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .value-display {
            color: #ff1493;
            font-weight: bold;
            display: inline-block;
            margin-left: 10px;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.9em;
            border: 1px solid rgba(255, 20, 147, 0.3);
        }
        
        .stats div {
            margin: 3px 0;
        }
        
        .training-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(255, 20, 147, 0.2);
            border: 1px solid rgba(255, 20, 147, 0.5);
            color: #fff;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-btn:hover {
            background: rgba(255, 20, 147, 0.4);
        }
        
        .dataset-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        
        .dataset-btn {
            padding: 5px;
            font-size: 0.7em;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 20, 147, 0.2);
        }
        
        .dataset-btn.active {
            background: rgba(255, 20, 147, 0.3);
        }
        
        .hyperparameters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        textarea {
            height: 60px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }
        
        @keyframes training {
            0% { opacity: 0.6; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.6; transform: scale(0.98); }
        }
        
        .training {
            animation: training 1.5s ease-in-out infinite;
        }
        
        .preset-datasets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .preset-btn {
            padding: 6px;
            font-size: 0.7em;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 20, 147, 0.2);
            color: #ccc;
        }
        
        .preset-btn:hover {
            background: rgba(255, 20, 147, 0.2);
        }
        
        .metrics-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .confusion-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin: 10px 0;
        }
        
        .matrix-cell {
            background: rgba(255, 20, 147, 0.2);
            padding: 5px;
            text-align: center;
            font-size: 0.8em;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>ğŸ¤– æ©Ÿæ¢°å­¦ç¿’ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å¯è¦–åŒ–ãƒ„ãƒ¼ãƒ«</h1>
            
            <div class="control-section">
                <h3>ğŸ¯ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é¸æŠ</h3>
                <div class="algorithm-types">
                    <button class="algo-btn active" onclick="selectAlgorithm('linear')">ç·šå½¢å›å¸°</button>
                    <button class="algo-btn" onclick="selectAlgorithm('logistic')">ãƒ­ã‚¸ã‚¹ãƒ†ã‚£ãƒƒã‚¯å›å¸°</button>
                    <button class="algo-btn" onclick="selectAlgorithm('knn')">k-NN</button>
                    <button class="algo-btn" onclick="selectAlgorithm('svm')">SVM</button>
                    <button class="algo-btn" onclick="selectAlgorithm('tree')">æ±ºå®šæœ¨</button>
                    <button class="algo-btn" onclick="selectAlgorithm('kmeans')">k-means</button>
                    <button class="algo-btn" onclick="selectAlgorithm('neural')">ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆ</button>
                    <button class="algo-btn" onclick="selectAlgorithm('perceptron')">ãƒ‘ãƒ¼ã‚»ãƒ—ãƒˆãƒ­ãƒ³</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ğŸ“Š ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ</h3>
                <div class="dataset-options">
                    <button class="dataset-btn active" onclick="selectDataset('linear')">ç·šå½¢</button>
                    <button class="dataset-btn" onclick="selectDataset('quadratic')">äºŒæ¬¡</button>
                    <button class="dataset-btn" onclick="selectDataset('circular')">å††å½¢</button>
                    <button class="dataset-btn" onclick="selectDataset('spiral')">èºæ—‹</button>
                    <button class="dataset-btn" onclick="selectDataset('clusters')">ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼</button>
                    <button class="dataset-btn" onclick="selectDataset('random')">ãƒ©ãƒ³ãƒ€ãƒ </button>
                </div>
                
                <div class="parameter-grid">
                    <div>
                        <label>ã‚µãƒ³ãƒ—ãƒ«æ•°: <span class="value-display" id="sampleCountDisplay">200</span></label>
                        <input type="range" id="sampleCount" min="50" max="1000" value="200">
                    </div>
                    <div>
                        <label>ãƒã‚¤ã‚º: <span class="value-display" id="noiseDisplay">0.1</span></label>
                        <input type="range" id="noise" min="0" max="1" step="0.05" value="0.1">
                    </div>
                </div>
                
                <button onclick="generateDataset()">ğŸ² ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆç”Ÿæˆ</button>
                <button onclick="addDataPoint()" style="font-size: 0.8em;">â• æ‰‹å‹•ãƒ‡ãƒ¼ã‚¿è¿½åŠ </button>
            </div>
            
            <div class="control-section">
                <h3>âš™ï¸ ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h3>
                <div class="hyperparameters">
                    <div>
                        <label>å­¦ç¿’ç‡: <span class="value-display" id="learningRateDisplay">0.01</span></label>
                        <input type="range" id="learningRate" min="0.001" max="1" step="0.001" value="0.01">
                    </div>
                    <div>
                        <label>ã‚¨ãƒãƒƒã‚¯æ•°: <span class="value-display" id="epochsDisplay">100</span></label>
                        <input type="range" id="epochs" min="10" max="1000" value="100">
                    </div>
                </div>
                
                <div class="hyperparameters">
                    <div>
                        <label>kå€¤ (k-NN): <span class="value-display" id="kValueDisplay">5</span></label>
                        <input type="range" id="kValue" min="1" max="20" value="5">
                    </div>
                    <div>
                        <label>Cå€¤ (SVM): <span class="value-display" id="cValueDisplay">1.0</span></label>
                        <input type="range" id="cValue" min="0.1" max="10" step="0.1" value="1">
                    </div>
                </div>
                
                <div class="hyperparameters">
                    <div>
                        <label>éš ã‚Œå±¤: <span class="value-display" id="hiddenLayersDisplay">1</span></label>
                        <input type="range" id="hiddenLayers" min="1" max="5" value="1">
                    </div>
                    <div>
                        <label>ãƒ‹ãƒ¥ãƒ¼ãƒ­ãƒ³æ•°: <span class="value-display" id="neuronsDisplay">10</span></label>
                        <input type="range" id="neurons" min="5" max="50" value="10">
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ğŸš€ å­¦ç¿’åˆ¶å¾¡</h3>
                <button onclick="startTraining()" id="trainBtn">â–¶ï¸ å­¦ç¿’é–‹å§‹</button>
                <button onclick="pauseTraining()" id="pauseBtn">â¸ï¸ ä¸€æ™‚åœæ­¢</button>
                <button onclick="resetModel()" id="resetBtn">ğŸ”„ ãƒ¢ãƒ‡ãƒ«ãƒªã‚»ãƒƒãƒˆ</button>
                <button onclick="stepTraining()" id="stepBtn">ğŸ‘£ ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ</button>
            </div>
            
            <div class="control-section">
                <h3>ğŸ“ˆ å¯è¦–åŒ–è¨­å®š</h3>
                <label>
                    <input type="checkbox" id="showDecisionBoundary" checked> æ±ºå®šå¢ƒç•Œè¡¨ç¤º
                </label>
                <label>
                    <input type="checkbox" id="showGradients"> å‹¾é…è¡¨ç¤º
                </label>
                <label>
                    <input type="checkbox" id="showConfidence"> ä¿¡é ¼åº¦è¡¨ç¤º
                </label>
                <label>
                    <input type="checkbox" id="animateTraining" checked> å­¦ç¿’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                </label>
                
                <label>è§£åƒåº¦: <span class="value-display" id="resolutionDisplay">50</span></label>
                <input type="range" id="resolution" min="20" max="100" value="50">
            </div>
            
            <div class="control-section">
                <h3>ğŸ“‹ ãƒ—ãƒªã‚»ãƒƒãƒˆ</h3>
                <div class="preset-datasets">
                    <button class="preset-btn" onclick="loadPreset('iris')">ã‚¢ã‚¤ãƒªã‚¹åˆ†é¡</button>
                    <button class="preset-btn" onclick="loadPreset('housing')">ä½å®…ä¾¡æ ¼äºˆæ¸¬</button>
                    <button class="preset-btn" onclick="loadPreset('xor')">XORå•é¡Œ</button>
                    <button class="preset-btn" onclick="loadPreset('moon')">åŠæœˆãƒ‡ãƒ¼ã‚¿</button>
                    <button class="preset-btn" onclick="loadPreset('blob')">ãƒ–ãƒ­ãƒ–åˆ†é¡</button>
                    <button class="preset-btn" onclick="loadPreset('diabetes')">ç³–å°¿ç—…äºˆæ¸¬</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ğŸ“Š ãƒ¢ãƒ‡ãƒ«è©•ä¾¡</h3>
                <div class="metrics-panel">
                    <div>ç²¾åº¦: <span id="accuracy">0.0%</span></div>
                    <div>æå¤±: <span id="loss">0.000</span></div>
                    <div>ç²¾å¯†åº¦: <span id="precision">0.0%</span></div>
                    <div>å†ç¾ç‡: <span id="recall">0.0%</span></div>
                    <div>F1ã‚¹ã‚³ã‚¢: <span id="f1Score">0.0%</span></div>
                    
                    <div style="margin-top: 10px; font-size: 0.8em;">æ··åŒè¡Œåˆ—:</div>
                    <div class="confusion-matrix" id="confusionMatrix">
                        <div class="matrix-cell">TP: 0</div>
                        <div class="matrix-cell">FP: 0</div>
                        <div class="matrix-cell">FN: 0</div>
                        <div class="matrix-cell">TN: 0</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <button onclick="exportModel()">ğŸ’¾ ãƒ¢ãƒ‡ãƒ«ä¿å­˜</button>
                <button onclick="generateReport()">ğŸ“„ ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ</button>
            </div>
        </div>
        
        <div class="main-canvas">
            <canvas id="canvas"></canvas>
            
            <div class="stats">
                <div>ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : <span id="currentAlgorithm">ç·šå½¢å›å¸°</span></div>
                <div>ãƒ‡ãƒ¼ã‚¿æ•°: <span id="dataCount">0</span></div>
                <div>ç‰¹å¾´é‡: <span id="featureCount">2</span></div>
                <div>ã‚¨ãƒãƒƒã‚¯: <span id="currentEpoch">0</span></div>
                <div>å­¦ç¿’çŠ¶æ…‹: <span id="trainingStatus">å¾…æ©Ÿä¸­</span></div>
                <div>è¨ˆç®—æ™‚é–“: <span id="computeTime">0</span>ms</div>
            </div>
            
            <div class="training-controls">
                <button class="control-btn" onclick="addPositivePoint()" title="æ­£ä¾‹è¿½åŠ ">+</button>
                <button class="control-btn" onclick="addNegativePoint()" title="è² ä¾‹è¿½åŠ ">-</button>
                <button class="control-btn" onclick="clearData()" title="ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢">ğŸ—‘ï¸</button>
                <button class="control-btn" onclick="shuffle()" title="ãƒ‡ãƒ¼ã‚¿ã‚·ãƒ£ãƒƒãƒ•ãƒ«">ğŸ”€</button>
                <button class="control-btn" onclick="splitData()" title="è¨“ç·´/ãƒ†ã‚¹ãƒˆåˆ†å‰²">âœ‚ï¸</button>
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let dataPoints = [];
        let testPoints = [];
        let currentAlgorithm = 'linear';
        let currentDataset = 'linear';
        let model = null;
        let isTraining = false;
        let trainingEpoch = 0;
        let animationId = null;
        let decisionBoundary = [];
        
        // æ©Ÿæ¢°å­¦ç¿’ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…
        class MachineLearningModel {
            constructor(type) {
                this.type = type;
                this.weights = [];
                this.bias = 0;
                this.isClassification = ['logistic', 'svm', 'knn', 'tree', 'perceptron'].includes(type);
                this.history = { loss: [], accuracy: [] };
                this.initialize();
            }
            
            initialize() {
                const featureCount = 2;
                switch (this.type) {
                    case 'linear':
                    case 'logistic':
                    case 'perceptron':
                        this.weights = Array(featureCount).fill(0).map(() => Math.random() * 0.1 - 0.05);
                        this.bias = Math.random() * 0.1 - 0.05;
                        break;
                    case 'neural':
                        this.initializeNeuralNetwork();
                        break;
                    case 'svm':
                        this.weights = Array(featureCount).fill(0).map(() => Math.random() * 0.1 - 0.05);
                        this.bias = 0;
                        break;
                    case 'tree':
                        this.tree = null;
                        break;
                    case 'kmeans':
                        this.centroids = [];
                        this.initializeCentroids();
                        break;
                }
            }
            
            initializeNeuralNetwork() {
                const hiddenLayers = parseInt(document.getElementById('hiddenLayers').value);
                const neurons = parseInt(document.getElementById('neurons').value);
                
                this.layers = [];
                const layerSizes = [2]; // å…¥åŠ›å±¤
                
                for (let i = 0; i < hiddenLayers; i++) {
                    layerSizes.push(neurons);
                }
                layerSizes.push(this.isClassification ? 2 : 1); // å‡ºåŠ›å±¤
                
                for (let i = 0; i < layerSizes.length - 1; i++) {
                    const weights = [];
                    for (let j = 0; j < layerSizes[i]; j++) {
                        weights.push(Array(layerSizes[i + 1]).fill(0).map(() => Math.random() * 0.4 - 0.2));
                    }
                    this.layers.push({
                        weights: weights,
                        biases: Array(layerSizes[i + 1]).fill(0).map(() => Math.random() * 0.1 - 0.05)
                    });
                }
            }
            
            initializeCentroids() {
                const k = parseInt(document.getElementById('kValue').value);
                this.centroids = [];
                
                for (let i = 0; i < k; i++) {
                    this.centroids.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    });
                }
            }
            
            predict(x, y) {
                const features = [x / canvas.width, y / canvas.height]; // æ­£è¦åŒ–
                
                switch (this.type) {
                    case 'linear':
                        return this.linearPredict(features);
                    case 'logistic':
                        return this.logisticPredict(features);
                    case 'knn':
                        return this.knnPredict(x, y);
                    case 'svm':
                        return this.svmPredict(features);
                    case 'perceptron':
                        return this.perceptronPredict(features);
                    case 'neural':
                        return this.neuralPredict(features);
                    case 'tree':
                        return this.treePredict(features);
                    case 'kmeans':
                        return this.kmeansPredict(x, y);
                    default:
                        return 0;
                }
            }
            
            linearPredict(features) {
                let prediction = this.bias;
                for (let i = 0; i < features.length; i++) {
                    prediction += this.weights[i] * features[i];
                }
                return prediction;
            }
            
            logisticPredict(features) {
                const z = this.linearPredict(features);
                return 1 / (1 + Math.exp(-z));
            }
            
            knnPredict(x, y) {
                const k = parseInt(document.getElementById('kValue').value);
                const distances = dataPoints.map(point => ({
                    distance: Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2),
                    label: point.label
                }));
                
                distances.sort((a, b) => a.distance - b.distance);
                const nearestK = distances.slice(0, k);
                
                if (this.isClassification) {
                    const votes = {};
                    nearestK.forEach(neighbor => {
                        votes[neighbor.label] = (votes[neighbor.label] || 0) + 1;
                    });
                    return Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
                } else {
                    return nearestK.reduce((sum, neighbor) => sum + neighbor.label, 0) / k;
                }
            }
            
            svmPredict(features) {
                let decision = this.bias;
                for (let i = 0; i < features.length; i++) {
                    decision += this.weights[i] * features[i];
                }
                return decision > 0 ? 1 : 0;
            }
            
            perceptronPredict(features) {
                let activation = this.bias;
                for (let i = 0; i < features.length; i++) {
                    activation += this.weights[i] * features[i];
                }
                return activation > 0 ? 1 : 0;
            }
            
            neuralPredict(features) {
                let activations = features;
                
                for (const layer of this.layers) {
                    const newActivations = [];
                    
                    for (let j = 0; j < layer.biases.length; j++) {
                        let sum = layer.biases[j];
                        for (let i = 0; i < activations.length; i++) {
                            sum += activations[i] * layer.weights[i][j];
                        }
                        newActivations.push(this.sigmoid(sum));
                    }
                    
                    activations = newActivations;
                }
                
                return this.isClassification ? (activations[0] > 0.5 ? 1 : 0) : activations[0];
            }
            
            treePredict(features) {
                if (!this.tree) return 0;
                return this.traverseTree(this.tree, features);
            }
            
            kmeansPredict(x, y) {
                let minDistance = Infinity;
                let closestCluster = 0;
                
                for (let i = 0; i < this.centroids.length; i++) {
                    const distance = Math.sqrt((this.centroids[i].x - x) ** 2 + (this.centroids[i].y - y) ** 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCluster = i;
                    }
                }
                
                return closestCluster;
            }
            
            train() {
                if (dataPoints.length === 0) return;
                
                const learningRate = parseFloat(document.getElementById('learningRate').value);
                
                switch (this.type) {
                    case 'linear':
                    case 'logistic':
                        this.gradientDescentStep(learningRate);
                        break;
                    case 'perceptron':
                        this.perceptronStep(learningRate);
                        break;
                    case 'neural':
                        this.backpropagationStep(learningRate);
                        break;
                    case 'svm':
                        this.svmStep(learningRate);
                        break;
                    case 'tree':
                        this.buildDecisionTree();
                        break;
                    case 'kmeans':
                        this.kmeansStep();
                        break;
                }
                
                this.updateMetrics();
            }
            
            gradientDescentStep(learningRate) {
                let weightGradients = Array(this.weights.length).fill(0);
                let biasGradient = 0;
                
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    const prediction = this.type === 'linear' ? 
                        this.linearPredict(features) : 
                        this.logisticPredict(features);
                    
                    const error = point.label - prediction;
                    
                    if (this.type === 'logistic') {
                        const derivative = prediction * (1 - prediction);
                        for (let i = 0; i < features.length; i++) {
                            weightGradients[i] += error * derivative * features[i];
                        }
                        biasGradient += error * derivative;
                    } else {
                        for (let i = 0; i < features.length; i++) {
                            weightGradients[i] += error * features[i];
                        }
                        biasGradient += error;
                    }
                }
                
                // é‡ã¿æ›´æ–°
                for (let i = 0; i < this.weights.length; i++) {
                    this.weights[i] += learningRate * weightGradients[i] / dataPoints.length;
                }
                this.bias += learningRate * biasGradient / dataPoints.length;
            }
            
            perceptronStep(learningRate) {
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    const prediction = this.perceptronPredict(features);
                    const error = point.label - prediction;
                    
                    if (error !== 0) {
                        for (let i = 0; i < features.length; i++) {
                            this.weights[i] += learningRate * error * features[i];
                        }
                        this.bias += learningRate * error;
                    }
                }
            }
            
            backpropagationStep(learningRate) {
                // ç°¡ç•¥åŒ–ã•ã‚ŒãŸãƒãƒƒã‚¯ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    const prediction = this.neuralPredict(features);
                    const error = point.label - prediction;
                    
                    // å‡ºåŠ›å±¤ã®é‡ã¿æ›´æ–°ï¼ˆç°¡ç•¥ç‰ˆï¼‰
                    const lastLayer = this.layers[this.layers.length - 1];
                    for (let i = 0; i < lastLayer.weights.length; i++) {
                        for (let j = 0; j < lastLayer.weights[i].length; j++) {
                            lastLayer.weights[i][j] += learningRate * error * 0.1;
                        }
                    }
                }
            }
            
            svmStep(learningRate) {
                const C = parseFloat(document.getElementById('cValue').value);
                
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    let decision = this.bias;
                    for (let i = 0; i < features.length; i++) {
                        decision += this.weights[i] * features[i];
                    }
                    
                    const margin = point.label * decision;
                    
                    if (margin < 1) {
                        // ã‚µãƒãƒ¼ãƒˆãƒ™ã‚¯ã‚¿ãƒ¼
                        for (let i = 0; i < features.length; i++) {
                            this.weights[i] += learningRate * (point.label * features[i] - 2 * this.weights[i] / C);
                        }
                        this.bias += learningRate * point.label;
                    } else {
                        // æ­£å‰‡åŒ–é …ã®ã¿
                        for (let i = 0; i < features.length; i++) {
                            this.weights[i] += learningRate * (-2 * this.weights[i] / C);
                        }
                    }
                }
            }
            
            kmeansStep() {
                // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å‰²ã‚Šå½“ã¦
                const clusters = Array(this.centroids.length).fill().map(() => []);
                
                for (const point of dataPoints) {
                    const clusterIndex = this.kmeansPredict(point.x, point.y);
                    clusters[clusterIndex].push(point);
                }
                
                // é‡å¿ƒæ›´æ–°
                for (let i = 0; i < this.centroids.length; i++) {
                    if (clusters[i].length > 0) {
                        const sumX = clusters[i].reduce((sum, point) => sum + point.x, 0);
                        const sumY = clusters[i].reduce((sum, point) => sum + point.y, 0);
                        this.centroids[i].x = sumX / clusters[i].length;
                        this.centroids[i].y = sumY / clusters[i].length;
                    }
                }
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }
            
            updateMetrics() {
                if (dataPoints.length === 0) return;
                
                let correct = 0;
                let totalLoss = 0;
                let tp = 0, fp = 0, fn = 0, tn = 0;
                
                for (const point of dataPoints) {
                    const prediction = this.predict(point.x, point.y);
                    
                    if (this.isClassification) {
                        const predicted = prediction > 0.5 ? 1 : 0;
                        const actual = point.label;
                        
                        if (predicted === actual) correct++;
                        
                        if (actual === 1 && predicted === 1) tp++;
                        else if (actual === 0 && predicted === 1) fp++;
                        else if (actual === 1 && predicted === 0) fn++;
                        else if (actual === 0 && predicted === 0) tn++;
                        
                        // ã‚¯ãƒ­ã‚¹ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼æå¤±
                        const p = Math.max(0.0001, Math.min(0.9999, prediction));
                        totalLoss += -(actual * Math.log(p) + (1 - actual) * Math.log(1 - p));
                    } else {
                        // å¹³å‡äºŒä¹—èª¤å·®
                        const error = prediction - point.label;
                        totalLoss += error * error;
                        
                        // å›å¸°ã®ç²¾åº¦ï¼ˆèª¤å·®ãŒå°ã•ã‘ã‚Œã°æ­£è§£ã¨ã¿ãªã™ï¼‰
                        if (Math.abs(error) < 0.1) correct++;
                    }
                }
                
                const accuracy = (correct / dataPoints.length) * 100;
                const loss = totalLoss / dataPoints.length;
                
                document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
                document.getElementById('loss').textContent = loss.toFixed(3);
                
                if (this.isClassification) {
                    const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
                    const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
                    const f1 = precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0;
                    
                    document.getElementById('precision').textContent = (precision * 100).toFixed(1) + '%';
                    document.getElementById('recall').textContent = (recall * 100).toFixed(1) + '%';
                    document.getElementById('f1Score').textContent = (f1 * 100).toFixed(1) + '%';
                    
                    // æ··åŒè¡Œåˆ—æ›´æ–°
                    const matrix = document.getElementById('confusionMatrix');
                    matrix.children[0].textContent = `TP: ${tp}`;
                    matrix.children[1].textContent = `FP: ${fp}`;
                    matrix.children[2].textContent = `FN: ${fn}`;
                    matrix.children[3].textContent = `TN: ${tn}`;
                }
                
                this.history.accuracy.push(accuracy);
                this.history.loss.push(loss);
            }
        }
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹åˆæœŸåŒ–
        function initCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }
        
        // ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é¸æŠ
        function selectAlgorithm(algorithm) {
            currentAlgorithm = algorithm;
            document.querySelectorAll('.algo-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const names = {
                linear: 'ç·šå½¢å›å¸°',
                logistic: 'ãƒ­ã‚¸ã‚¹ãƒ†ã‚£ãƒƒã‚¯å›å¸°',
                knn: 'k-NN',
                svm: 'SVM',
                tree: 'æ±ºå®šæœ¨',
                kmeans: 'k-means',
                neural: 'ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆ',
                perceptron: 'ãƒ‘ãƒ¼ã‚»ãƒ—ãƒˆãƒ­ãƒ³'
            };
            
            document.getElementById('currentAlgorithm').textContent = names[algorithm];
            resetModel();
        }
        
        // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆé¸æŠãƒ»ç”Ÿæˆ
        function selectDataset(dataset) {
            currentDataset = dataset;
            document.querySelectorAll('.dataset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            generateDataset();
        }
        
        function generateDataset() {
            const sampleCount = parseInt(document.getElementById('sampleCount').value);
            const noise = parseFloat(document.getElementById('noise').value);
            
            dataPoints = [];
            
            switch (currentDataset) {
                case 'linear':
                    generateLinearData(sampleCount, noise);
                    break;
                case 'quadratic':
                    generateQuadraticData(sampleCount, noise);
                    break;
                case 'circular':
                    generateCircularData(sampleCount, noise);
                    break;
                case 'spiral':
                    generateSpiralData(sampleCount, noise);
                    break;
                case 'clusters':
                    generateClusterData(sampleCount, noise);
                    break;
                case 'random':
                    generateRandomData(sampleCount);
                    break;
            }
            
            updateStats();
            draw();
        }
        
        function generateLinearData(count, noise) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * canvas.width;
                const y = x * 0.5 + canvas.height * 0.3 + (Math.random() - 0.5) * noise * canvas.height;
                const label = currentAlgorithm === 'kmeans' ? 0 : (y > canvas.height / 2 ? 1 : 0);
                dataPoints.push({x, y, label});
            }
        }
        
        function generateQuadraticData(count, noise) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * canvas.width;
                const normalizedX = (x / canvas.width - 0.5) * 4;
                const y = canvas.height * (0.5 - normalizedX * normalizedX * 0.1) + (Math.random() - 0.5) * noise * canvas.height;
                const label = y < canvas.height / 2 ? 1 : 0;
                dataPoints.push({x, y: Math.max(0, Math.min(canvas.height, y)), label});
            }
        }
        
        function generateCircularData(count, noise) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 150 + 50 + (Math.random() - 0.5) * noise * 50;
                const x = canvas.width / 2 + radius * Math.cos(angle);
                const y = canvas.height / 2 + radius * Math.sin(angle);
                const centerDistance = Math.sqrt((x - canvas.width/2)**2 + (y - canvas.height/2)**2);
                const label = centerDistance < 100 ? 1 : 0;
                dataPoints.push({x: Math.max(0, Math.min(canvas.width, x)), 
                               y: Math.max(0, Math.min(canvas.height, y)), label});
            }
        }
        
        function generateSpiralData(count, noise) {
            for (let i = 0; i < count; i++) {
                const t = i / count * 4 * Math.PI;
                const radius = t * 10;
                const x = canvas.width / 2 + radius * Math.cos(t) + (Math.random() - 0.5) * noise * 20;
                const y = canvas.height / 2 + radius * Math.sin(t) + (Math.random() - 0.5) * noise * 20;
                const label = Math.floor(t / (2 * Math.PI)) % 2;
                dataPoints.push({x: Math.max(0, Math.min(canvas.width, x)), 
                               y: Math.max(0, Math.min(canvas.height, y)), label});
            }
        }
        
        function generateClusterData(count, noise) {
            const centers = [
                {x: canvas.width * 0.3, y: canvas.height * 0.3},
                {x: canvas.width * 0.7, y: canvas.height * 0.3},
                {x: canvas.width * 0.5, y: canvas.height * 0.7}
            ];
            
            for (let i = 0; i < count; i++) {
                const cluster = Math.floor(Math.random() * centers.length);
                const center = centers[cluster];
                const x = center.x + (Math.random() - 0.5) * 100 + (Math.random() - 0.5) * noise * 50;
                const y = center.y + (Math.random() - 0.5) * 100 + (Math.random() - 0.5) * noise * 50;
                dataPoints.push({x: Math.max(0, Math.min(canvas.width, x)), 
                               y: Math.max(0, Math.min(canvas.height, y)), label: cluster});
            }
        }
        
        function generateRandomData(count) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const label = Math.random() > 0.5 ? 1 : 0;
                dataPoints.push({x, y, label});
            }
        }
        
        // å­¦ç¿’åˆ¶å¾¡
        function startTraining() {
            if (!model) {
                model = new MachineLearningModel(currentAlgorithm);
            }
            
            if (!isTraining) {
                isTraining = true;
                document.getElementById('trainingStatus').textContent = 'å­¦ç¿’ä¸­';
                trainModel();
            }
        }
        
        function pauseTraining() {
            isTraining = false;
            document.getElementById('trainingStatus').textContent = 'ä¸€æ™‚åœæ­¢';
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function resetModel() {
            pauseTraining();
            model = new MachineLearningModel(currentAlgorithm);
            trainingEpoch = 0;
            document.getElementById('currentEpoch').textContent = '0';
            document.getElementById('trainingStatus').textContent = 'å¾…æ©Ÿä¸­';
            updateDecisionBoundary();
            draw();
        }
        
        function stepTraining() {
            if (!model) {
                model = new MachineLearningModel(currentAlgorithm);
            }
            
            model.train();
            trainingEpoch++;
            document.getElementById('currentEpoch').textContent = trainingEpoch;
            updateDecisionBoundary();
            draw();
        }
        
        async function trainModel() {
            const maxEpochs = parseInt(document.getElementById('epochs').value);
            const animateTraining = document.getElementById('animateTraining').checked;
            
            while (isTraining && trainingEpoch < maxEpochs) {
                const startTime = performance.now();
                
                model.train();
                trainingEpoch++;
                
                document.getElementById('currentEpoch').textContent = trainingEpoch;
                
                if (animateTraining && trainingEpoch % 5 === 0) {
                    updateDecisionBoundary();
                    draw();
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                const endTime = performance.now();
                document.getElementById('computeTime').textContent = Math.round(endTime - startTime);
            }
            
            if (trainingEpoch >= maxEpochs) {
                pauseTraining();
                document.getElementById('trainingStatus').textContent = 'å®Œäº†';
            }
            
            updateDecisionBoundary();
            draw();
        }
        
        // æ±ºå®šå¢ƒç•Œæ›´æ–°
        function updateDecisionBoundary() {
            if (!model || !document.getElementById('showDecisionBoundary').checked) {
                decisionBoundary = [];
                return;
            }
            
            const resolution = parseInt(document.getElementById('resolution').value);
            const stepX = canvas.width / resolution;
            const stepY = canvas.height / resolution;
            
            decisionBoundary = [];
            
            for (let x = 0; x < canvas.width; x += stepX) {
                for (let y = 0; y < canvas.height; y += stepY) {
                    const prediction = model.predict(x, y);
                    decisionBoundary.push({x, y, prediction});
                }
            }
        }
        
        // æç”»
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, canvas.width/2
            );
            gradient.addColorStop(0, 'rgba(15, 15, 35, 0.1)');
            gradient.addColorStop(1, 'rgba(139, 0, 139, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ±ºå®šå¢ƒç•Œæç”»
            drawDecisionBoundary();
            
            // ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆæç”»
            drawDataPoints();
            
            // k-meansã®é‡å¿ƒæç”»
            if (model && model.type === 'kmeans') {
                drawCentroids();
            }
        }
        
        function drawDecisionBoundary() {
            if (decisionBoundary.length === 0) return;
            
            const resolution = parseInt(document.getElementById('resolution').value);
            const stepX = canvas.width / resolution;
            const stepY = canvas.height / resolution;
            
            for (const point of decisionBoundary) {
                let alpha = 0.3;
                let color;
                
                if (model.isClassification || model.type === 'kmeans') {
                    const hue = point.prediction * 60; // è‰²ç›¸ã§åˆ†é¡
                    color = `hsla(${hue}, 70%, 50%, ${alpha})`;
                } else {
                    // å›å¸°ã®å ´åˆã¯å€¤ã«å¿œã˜ã¦è‰²ã‚’å¤‰ãˆã‚‹
                    const intensity = Math.max(0, Math.min(1, point.prediction));
                    color = `rgba(${intensity * 255}, ${(1-intensity) * 255}, 100, ${alpha})`;
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(point.x, point.y, stepX, stepY);
            }
        }
        
        function drawDataPoints() {
            for (const point of dataPoints) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                
                if (currentAlgorithm === 'kmeans') {
                    const hue = point.label * 60;
                    ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                } else {
                    ctx.fillStyle = point.label > 0.5 ? '#ff6b6b' : '#4ecdc4';
                }
                
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        function drawCentroids() {
            for (let i = 0; i < model.centroids.length; i++) {
                const centroid = model.centroids[i];
                ctx.beginPath();
                ctx.arc(centroid.x, centroid.y, 12, 0, Math.PI * 2);
                
                const hue = i * 60;
                ctx.fillStyle = `hsl(${hue}, 70%, 40%)`;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Xå°
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centroid.x - 6, centroid.y - 6);
                ctx.lineTo(centroid.x + 6, centroid.y + 6);
                ctx.moveTo(centroid.x + 6, centroid.y - 6);
                ctx.lineTo(centroid.x - 6, centroid.y + 6);
                ctx.stroke();
            }
        }
        
        // ãƒ‡ãƒ¼ã‚¿æ“ä½œ
        function addDataPoint() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const label = Math.random() > 0.5 ? 1 : 0;
            dataPoints.push({x, y, label});
            updateStats();
            draw();
        }
        
        function addPositivePoint() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            dataPoints.push({x, y, label: 1});
            updateStats();
            draw();
        }
        
        function addNegativePoint() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            dataPoints.push({x, y, label: 0});
            updateStats();
            draw();
        }
        
        function clearData() {
            dataPoints = [];
            testPoints = [];
            updateStats();
            draw();
        }
        
        function shuffle() {
            for (let i = dataPoints.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [dataPoints[i], dataPoints[j]] = [dataPoints[j], dataPoints[i]];
            }
            draw();
        }
        
        function splitData() {
            const splitRatio = 0.8;
            const trainSize = Math.floor(dataPoints.length * splitRatio);
            
            shuffle();
            testPoints = dataPoints.splice(trainSize);
            
            console.log(`è¨“ç·´ãƒ‡ãƒ¼ã‚¿: ${dataPoints.length}, ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿: ${testPoints.length}`);
            updateStats();
        }
        
        // ãƒ—ãƒªã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿
        function loadPreset(preset) {
            switch (preset) {
                case 'iris':
                    selectAlgorithm('logistic');
                    selectDataset('clusters');
                    break;
                case 'housing':
                    selectAlgorithm('linear');
                    selectDataset('linear');
                    break;
                case 'xor':
                    selectAlgorithm('neural');
                    loadXORData();
                    break;
                case 'moon':
                    selectAlgorithm('svm');
                    selectDataset('circular');
                    break;
                case 'blob':
                    selectAlgorithm('kmeans');
                    selectDataset('clusters');
                    break;
                case 'diabetes':
                    selectAlgorithm('logistic');
                    selectDataset('random');
                    break;
            }
        }
        
        function loadXORData() {
            dataPoints = [
                {x: canvas.width * 0.3, y: canvas.height * 0.3, label: 0},
                {x: canvas.width * 0.7, y: canvas.height * 0.3, label: 1},
                {x: canvas.width * 0.3, y: canvas.height * 0.7, label: 1},
                {x: canvas.width * 0.7, y: canvas.height * 0.7, label: 0}
            ];
            
            // ãƒã‚¤ã‚ºä»˜ãã‚µãƒ³ãƒ—ãƒ«è¿½åŠ 
            for (let i = 0; i < 100; i++) {
                const basePoint = dataPoints[i % 4];
                const x = basePoint.x + (Math.random() - 0.5) * 60;
                const y = basePoint.y + (Math.random() - 0.5) * 60;
                dataPoints.push({x, y, label: basePoint.label});
            }
            
            updateStats();
            draw();
        }
        
        // çµ±è¨ˆæ›´æ–°
        function updateStats() {
            document.getElementById('dataCount').textContent = dataPoints.length;
            document.getElementById('sampleCountDisplay').textContent = document.getElementById('sampleCount').value;
            document.getElementById('noiseDisplay').textContent = document.getElementById('noise').value;
        }
        
        // è¡¨ç¤ºå€¤æ›´æ–°
        function updateDisplayValues() {
            document.getElementById('learningRateDisplay').textContent = document.getElementById('learningRate').value;
            document.getElementById('epochsDisplay').textContent = document.getElementById('epochs').value;
            document.getElementById('kValueDisplay').textContent = document.getElementById('kValue').value;
            document.getElementById('cValueDisplay').textContent = document.getElementById('cValue').value;
            document.getElementById('hiddenLayersDisplay').textContent = document.getElementById('hiddenLayers').value;
            document.getElementById('neuronsDisplay').textContent = document.getElementById('neurons').value;
            document.getElementById('resolutionDisplay').textContent = document.getElementById('resolution').value;
        }
        
        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½
        function exportModel() {
            if (!model) return;
            
            const data = {
                algorithm: currentAlgorithm,
                weights: model.weights,
                bias: model.bias,
                history: model.history,
                dataPoints: dataPoints,
                parameters: {
                    learningRate: parseFloat(document.getElementById('learningRate').value),
                    epochs: parseInt(document.getElementById('epochs').value)
                }
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ml_model_${currentAlgorithm}_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function generateReport() {
            let report = `æ©Ÿæ¢°å­¦ç¿’ãƒ¬ãƒãƒ¼ãƒˆ\n`;
            report += `ç”Ÿæˆæ—¥æ™‚: ${new Date().toLocaleString()}\n\n`;
            report += `ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : ${currentAlgorithm}\n`;
            report += `ãƒ‡ãƒ¼ã‚¿æ•°: ${dataPoints.length}\n`;
            report += `ã‚¨ãƒãƒƒã‚¯æ•°: ${trainingEpoch}\n\n`;
            
            if (model) {
                const accuracy = document.getElementById('accuracy').textContent;
                const loss = document.getElementById('loss').textContent;
                report += `ç²¾åº¦: ${accuracy}\n`;
                report += `æå¤±: ${loss}\n`;
            }
            
            const reportBlob = new Blob([report], {type: 'text/plain'});
            const url = URL.createObjectURL(reportBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ml_report_${Date.now()}.txt`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // ãƒã‚¦ã‚¹ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const label = e.shiftKey ? 0 : 1; // Shiftã‚­ãƒ¼ã§è² ä¾‹
            dataPoints.push({x, y, label});
            updateStats();
            draw();
        });
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        ['learningRate', 'epochs', 'kValue', 'cValue', 'hiddenLayers', 'neurons', 'resolution', 'sampleCount', 'noise'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateDisplayValues);
        });
        
        document.getElementById('showDecisionBoundary').addEventListener('change', () => {
            updateDecisionBoundary();
            draw();
        });
        
        // åˆæœŸåŒ–
        window.addEventListener('resize', initCanvas);
        initCanvas();
        updateDisplayValues();
        generateDataset();
        resetModel();
    </script>
</body>
</html>