<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«¹åˆ‡ã‚Šã‚²ãƒ¼ãƒ  - çˆ½å¿«æ–¬æ’ƒä½“é¨“</title>
    <meta name="description" content="ãƒªã‚¢ãƒ«ãªç‰©ç†æ¼”ç®—ã§ç«¹ã‚’ã‚¹ãƒ‘ãƒƒã¨åˆ‡ã‚‹çˆ½å¿«ã‚²ãƒ¼ãƒ ">
    
    <!-- PWAè¨­å®š -->
    <meta name="theme-color" content="#2E7D32">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ç«¹åˆ‡ã‚Šã‚²ãƒ¼ãƒ ">
    
    <link rel="manifest" id="manifest-placeholder">
    <link rel="icon" type="image/png" sizes="192x192" id="icon-placeholder">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            display: block;
            cursor: none;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 50%, #228B22 100%);
            touch-action: none;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .combo-display {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }

        .start-button {
            padding: 15px 30px;
            font-size: 24px;
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: all;
        }

        .start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .instructions {
            text-align: center;
            margin-bottom: 30px;
            font-size: 18px;
        }

        .slice-effect {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes sliceFlash {
            0% { opacity: 1; width: 2px; }
            100% { opacity: 0; width: 8px; }
        }

        .slice-line {
            background: linear-gradient(90deg, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,1) 50%, 
                rgba(255,255,255,0) 100%);
            animation: sliceFlash 0.3s ease-out;
        }

        @media (max-width: 768px) {
            .score-display, .combo-display {
                font-size: 20px;
            }
            
            .start-button {
                font-size: 20px;
                padding: 12px 24px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="score-display">
            ã‚¹ã‚³ã‚¢: <span id="score">0</span>
        </div>
        <div class="combo-display">
            ã‚³ãƒ³ãƒœ: <span id="combo">0</span>
        </div>
    </div>

    <div class="start-screen" id="startScreen">
        <div class="instructions">
            <h1>ğŸ‹ ç«¹åˆ‡ã‚Šã‚²ãƒ¼ãƒ  ğŸ‹</h1>
            <p>ã‚¹ãƒ¯ã‚¤ãƒ—ã—ã¦ç«¹ã‚’ã‚¹ãƒ‘ãƒƒã¨åˆ‡ã‚ã†ï¼</p>
            <p>é€£ç¶šã§åˆ‡ã£ã¦ã‚³ãƒ³ãƒœã‚’æ±ºã‚ã‚ˆã†ï¼</p>
        </div>
        <button class="start-button" onclick="startGame()">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
    </div>

    <script>
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†
        let gameState = {
            isPlaying: false,
            score: 0,
            combo: 0,
            comboTimer: 0,
            lastCutTime: 0
        };

        // Canvasè¨­å®š
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ç‰©ç†æ¼”ç®—ç”¨ã®å®šæ•°
        const GRAVITY = 0.5;
        const FRICTION = 0.98;
        const BOUNCE_DAMPING = 0.7;

        // ç«¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—
        let bamboos = [];
        let particles = [];
        let sliceEffects = [];

        // éŸ³éŸ¿ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆWeb Audio APIä½¿ç”¨ï¼‰
        let audioContext;
        let masterGainNode;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGainNode = audioContext.createGain();
                masterGainNode.connect(audioContext.destination);
                masterGainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }

        // åˆ‡æ–­éŸ³ã®ç”Ÿæˆ
        function playSliceSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(masterGainNode);
            
            // é‹­ã„åˆ‡æ–­éŸ³
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
            
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(2000, audioContext.currentTime);
            filterNode.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        // ã‚³ãƒ³ãƒœéŸ³ã®ç”Ÿæˆ
        function playComboSound(comboCount) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);
            
            // ã‚³ãƒ³ãƒœæ•°ã«å¿œã˜ã¦éŸ³ç¨‹ã‚’ä¸Šã’ã‚‹
            const frequency = 440 + (comboCount * 50);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        // ç«¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹
        class Bamboo {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20 + Math.random() * 10;
                this.height = 100 + Math.random() * 50;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = Math.random() * -5 - 2;
                this.rotation = Math.random() * Math.PI * 2;
                this.angularVelocity = (Math.random() - 0.5) * 0.2;
                this.color = `hsl(${80 + Math.random() * 40}, 60%, 40%)`;
                this.segments = Math.floor(this.height / 15);
                this.isSliced = false;
                this.sliceY = 0;
                this.upperPart = null;
                this.lowerPart = null;
            }

            update() {
                if (!this.isSliced) {
                    this.vy += GRAVITY;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.rotation += this.angularVelocity;
                    
                    this.vx *= FRICTION;
                    this.vy *= FRICTION;

                    // ç”»é¢å¤–åˆ¤å®š
                    if (this.y > canvas.height + 100) {
                        return false;
                    }
                } else {
                    // ã‚¹ãƒ©ã‚¤ã‚¹ã•ã‚ŒãŸå¾Œã®ç‰©ç†æ¼”ç®—
                    if (this.upperPart) {
                        this.upperPart.vy += GRAVITY;
                        this.upperPart.x += this.upperPart.vx;
                        this.upperPart.y += this.upperPart.vy;
                        this.upperPart.rotation += this.upperPart.angularVelocity;
                        this.upperPart.vx *= FRICTION;
                        this.upperPart.vy *= FRICTION;
                    }
                    
                    if (this.lowerPart) {
                        this.lowerPart.vy += GRAVITY;
                        this.lowerPart.x += this.lowerPart.vx;
                        this.lowerPart.y += this.lowerPart.vy;
                        this.lowerPart.rotation += this.lowerPart.angularVelocity;
                        this.lowerPart.vx *= FRICTION;
                        this.lowerPart.vy *= FRICTION;
                    }

                    // ç”»é¢å¤–åˆ¤å®š
                    if (this.upperPart && this.upperPart.y > canvas.height + 100) {
                        this.upperPart = null;
                    }
                    if (this.lowerPart && this.lowerPart.y > canvas.height + 100) {
                        this.lowerPart = null;
                    }
                    
                    if (!this.upperPart && !this.lowerPart) {
                        return false;
                    }
                }
                
                return true;
            }

            slice(sliceY) {
                if (this.isSliced) return false;
                
                // ç«¹ã®å¢ƒç•Œå†…ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹åˆ¤å®š
                const localSliceY = sliceY - this.y;
                if (localSliceY < 0 || localSliceY > this.height) return false;
                
                this.isSliced = true;
                this.sliceY = localSliceY;
                
                // ä¸Šéƒ¨ã¨ä¸‹éƒ¨ã®ãƒ‘ãƒ¼ãƒ„ã‚’ä½œæˆ
                this.upperPart = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.sliceY,
                    vx: this.vx + (Math.random() - 0.5) * 5,
                    vy: this.vy - Math.random() * 3,
                    rotation: this.rotation,
                    angularVelocity: (Math.random() - 0.5) * 0.3,
                    color: this.color
                };
                
                this.lowerPart = {
                    x: this.x,
                    y: this.y + this.sliceY,
                    width: this.width,
                    height: this.height - this.sliceY,
                    vx: this.vx + (Math.random() - 0.5) * 5,
                    vy: this.vy - Math.random() * 3,
                    rotation: this.rotation,
                    angularVelocity: (Math.random() - 0.5) * 0.3,
                    color: this.color
                };
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
                this.createSliceParticles(this.x, sliceY);
                
                return true;
            }

            createSliceParticles(x, y) {
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: x + (Math.random() - 0.5) * this.width,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        size: Math.random() * 4 + 2,
                        color: this.color,
                        life: 1.0,
                        decay: 0.02 + Math.random() * 0.02
                    });
                }
            }

            draw() {
                ctx.save();
                
                if (!this.isSliced) {
                    // é€šå¸¸ã®ç«¹æç”»
                    ctx.translate(this.x + this.width/2, this.y + this.height/2);
                    ctx.rotate(this.rotation);
                    
                    // ç«¹ã®æœ¬ä½“
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    
                    // ç«¹ã®ç¯€
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 2;
                    for (let i = 1; i < this.segments; i++) {
                        const segmentY = -this.height/2 + (this.height / this.segments) * i;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2, segmentY);
                        ctx.lineTo(this.width/2, segmentY);
                        ctx.stroke();
                    }
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(-this.width/2, -this.height/2, this.width/3, this.height);
                    
                } else {
                    // ã‚¹ãƒ©ã‚¤ã‚¹ã•ã‚ŒãŸç«¹ã®æç”»
                    if (this.upperPart) {
                        this.drawBambooPart(this.upperPart);
                    }
                    if (this.lowerPart) {
                        this.drawBambooPart(this.lowerPart);
                    }
                }
                
                ctx.restore();
            }

            drawBambooPart(part) {
                ctx.save();
                ctx.translate(part.x + part.width/2, part.y + part.height/2);
                ctx.rotate(part.rotation);
                
                // ç«¹ã®æœ¬ä½“
                ctx.fillStyle = part.color;
                ctx.fillRect(-part.width/2, -part.height/2, part.width, part.height);
                
                // ç«¹ã®ç¯€
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                const segments = Math.floor(part.height / 15);
                for (let i = 1; i < segments; i++) {
                    const segmentY = -part.height/2 + (part.height / segments) * i;
                    ctx.beginPath();
                    ctx.moveTo(-part.width/2, segmentY);
                    ctx.lineTo(part.width/2, segmentY);
                    ctx.stroke();
                }
                
                // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(-part.width/2, -part.height/2, part.width/3, part.height);
                
                ctx.restore();
            }

            checkSlice(startX, startY, endX, endY) {
                if (this.isSliced) return false;
                
                // ç·šåˆ†ã¨çŸ©å½¢ã®äº¤å·®åˆ¤å®š
                const bambooLeft = this.x;
                const bambooRight = this.x + this.width;
                const bambooTop = this.y;
                const bambooBottom = this.y + this.height;
                
                // ã‚¹ãƒ©ã‚¤ã‚¹ç·šã¨ç«¹ã®å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ã®äº¤å·®ãƒã‚§ãƒƒã‚¯
                if (this.lineIntersectsRect(startX, startY, endX, endY, 
                    bambooLeft, bambooTop, bambooRight, bambooBottom)) {
                    
                    // äº¤å·®ç‚¹ã®Yåº§æ¨™ã‚’è¨ˆç®—
                    const sliceY = this.getIntersectionY(startX, startY, endX, endY);
                    return this.slice(sliceY);
                }
                
                return false;
            }

            lineIntersectsRect(x1, y1, x2, y2, left, top, right, bottom) {
                // ç·šåˆ†ã®ä¸¡ç«¯ãŒçŸ©å½¢å†…ã«ã‚ã‚‹å ´åˆ
                if ((x1 >= left && x1 <= right && y1 >= top && y1 <= bottom) ||
                    (x2 >= left && x2 <= right && y2 >= top && y2 <= bottom)) {
                    return true;
                }
                
                // ç·šåˆ†ã¨çŸ©å½¢ã®è¾ºã®äº¤å·®åˆ¤å®š
                return this.lineIntersectsLine(x1, y1, x2, y2, left, top, right, top) ||    // ä¸Šè¾º
                       this.lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom) || // å³è¾º
                       this.lineIntersectsLine(x1, y1, x2, y2, right, bottom, left, bottom) || // ä¸‹è¾º
                       this.lineIntersectsLine(x1, y1, x2, y2, left, bottom, left, top);     // å·¦è¾º
            }

            lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (denom === 0) return false;
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                return t >= 0 && t <= 1 && u >= 0 && u <= 1;
            }

            getIntersectionY(startX, startY, endX, endY) {
                // ç«¹ã®ä¸­å¤®ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹Yåº§æ¨™ã‚’è¿”ã™
                return this.y + this.height / 2;
            }
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°ã¨æç”»
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += GRAVITY * 0.3;
                particle.vx *= 0.99;
                particle.vy *= 0.99;
                particle.life -= particle.decay;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ã‚¹ãƒ©ã‚¤ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        function createSliceEffect(startX, startY, endX, endY) {
            const sliceDiv = document.createElement('div');
            sliceDiv.className = 'slice-effect slice-line';
            
            const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
            const angle = Math.atan2(endY - startY, endX - startX);
            
            sliceDiv.style.left = startX + 'px';
            sliceDiv.style.top = startY + 'px';
            sliceDiv.style.width = length + 'px';
            sliceDiv.style.height = '2px';
            sliceDiv.style.transform = `rotate(${angle}rad)`;
            sliceDiv.style.transformOrigin = '0 50%';
            
            document.body.appendChild(sliceDiv);
            
            setTimeout(() => {
                document.body.removeChild(sliceDiv);
            }, 300);
        }

        // ç«¹ã®ç”Ÿæˆ
        function spawnBamboo() {
            if (!gameState.isPlaying) return;
            
            const x = Math.random() * (canvas.width - 50);
            const y = -100 - Math.random() * 50; // ç”»é¢ä¸Šéƒ¨ã‹ã‚‰ç”Ÿæˆ
            bamboos.push(new Bamboo(x, y));
        }
        
        // åˆæœŸç«¹ã®ç”Ÿæˆï¼ˆã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ï¼‰
        function spawnInitialBamboos() {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    spawnBamboo();
                }, i * 300); // 0.3ç§’é–“éš”ã§3æœ¬ç”Ÿæˆ
            }
        }

        // ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹å…¥åŠ›å‡¦ç†
        let isSlicing = false;
        let sliceStart = { x: 0, y: 0 };
        let sliceEnd = { x: 0, y: 0 };
        let slicePath = [];

        function startSlice(x, y) {
            isSlicing = true;
            sliceStart = { x, y };
            sliceEnd = { x, y };
            slicePath = [{ x, y }];
        }

        function updateSlice(x, y) {
            if (!isSlicing) return;
            
            sliceEnd = { x, y };
            slicePath.push({ x, y });
            
            // ã‚¹ãƒ©ã‚¤ã‚¹è»Œè·¡ã®åˆ¶é™ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼‰
            if (slicePath.length > 10) {
                slicePath.shift();
            }
        }

        function endSlice() {
            if (!isSlicing) return;
            
            isSlicing = false;
            
            // ã‚¹ãƒ©ã‚¤ã‚¹ã®å®Ÿè¡Œ
            let slicedCount = 0;
            const currentTime = Date.now();
            
            for (let i = bamboos.length - 1; i >= 0; i--) {
                const bamboo = bamboos[i];
                
                // ã‚¹ãƒ©ã‚¤ã‚¹è»Œè·¡ã®å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã§åˆ¤å®š
                for (let j = 0; j < slicePath.length - 1; j++) {
                    const start = slicePath[j];
                    const end = slicePath[j + 1];
                    
                    if (bamboo.checkSlice(start.x, start.y, end.x, end.y)) {
                        slicedCount++;
                        break;
                    }
                }
            }
            
            if (slicedCount > 0) {
                // ã‚¹ã‚³ã‚¢æ›´æ–°
                gameState.score += slicedCount * 10;
                
                // ã‚³ãƒ³ãƒœå‡¦ç†
                if (currentTime - gameState.lastCutTime < 1000) {
                    gameState.combo += slicedCount;
                    gameState.score += gameState.combo * 5; // ã‚³ãƒ³ãƒœãƒœãƒ¼ãƒŠã‚¹
                    playComboSound(gameState.combo);
                } else {
                    gameState.combo = slicedCount;
                }
                
                gameState.lastCutTime = currentTime;
                gameState.comboTimer = currentTime + 3000; // 3ç§’ã§ã‚³ãƒ³ãƒœãƒªã‚»ãƒƒãƒˆ
                
                // ã‚¹ãƒ©ã‚¤ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                if (slicePath.length >= 2) {
                    createSliceEffect(slicePath[0].x, slicePath[0].y, 
                                    slicePath[slicePath.length-1].x, slicePath[slicePath.length-1].y);
                }
                
                // éŸ³éŸ¿ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                playSliceSound();
                
                // UIæ›´æ–°
                updateUI();
            }
            
            slicePath = [];
        }

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            startSlice(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            updateSlice(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mouseup', endSlice);

        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            startSlice(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            updateSlice(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            endSlice();
        });

        // UIæ›´æ–°
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('combo').textContent = gameState.combo;
        }

        // ã‚¹ãƒ©ã‚¤ã‚¹è»Œè·¡ã®æç”»
        function drawSlicePath() {
            if (slicePath.length < 2) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            ctx.moveTo(slicePath[0].x, slicePath[0].y);
            
            for (let i = 1; i < slicePath.length; i++) {
                ctx.lineTo(slicePath[i].x, slicePath[i].y);
            }
            
            ctx.stroke();
            ctx.restore();
        }

        // ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop() {
            // èƒŒæ™¯ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.isPlaying) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // ã‚³ãƒ³ãƒœã‚¿ã‚¤ãƒãƒ¼ç®¡ç†
            if (Date.now() > gameState.comboTimer) {
                gameState.combo = 0;
                updateUI();
            }
            
            // ç«¹ã®æ›´æ–°ã¨æç”»
            for (let i = bamboos.length - 1; i >= 0; i--) {
                if (!bamboos[i].update()) {
                    bamboos.splice(i, 1);
                }
            }
            
            for (const bamboo of bamboos) {
                bamboo.draw();
            }
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            updateParticles();
            
            // ã‚¹ãƒ©ã‚¤ã‚¹è»Œè·¡æç”»
            drawSlicePath();
            
            requestAnimationFrame(gameLoop);
        }

        // ç«¹ç”Ÿæˆé–¢æ•°
        function spawnBamboo() {
            const x = Math.random() * (canvas.width - 60) + 30;
            const y = -100 - Math.random() * 50; // ç”»é¢ä¸Šéƒ¨ã‹ã‚‰ç”Ÿæˆ
            const bamboo = new Bamboo(x, y);
            bamboos.push(bamboo);
            console.log('ç«¹ç”Ÿæˆ:', x, y); // ãƒ‡ãƒãƒƒã‚°ç”¨
        }

        // åˆæœŸç«¹ç”Ÿæˆé–¢æ•°
        function spawnInitialBamboos() {
            // å³åº§ã«3æœ¬ã®ç«¹ã‚’ç”Ÿæˆ
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    spawnBamboo();
                }, i * 300); // 0.3ç§’é–“éš”ã§ç”Ÿæˆ
            }
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.combo = 0;
            gameState.lastCutTime = 0;
            
            // é…åˆ—ã‚’ã‚¯ãƒªã‚¢
            bamboos = [];
            particles = [];
            
            initAudio();
            updateUI();
            
            // å³åº§ã«åˆæœŸç«¹ã‚’ç”Ÿæˆ
            spawnInitialBamboos();
            
            // ç«¹ã®å®šæœŸç”Ÿæˆï¼ˆã‚ˆã‚Šé »ç¹ã«ï¼‰
            const bambooSpawner = setInterval(() => {
                if (gameState.isPlaying && Math.random() < 0.8) {
                    spawnBamboo();
                } else if (!gameState.isPlaying) {
                    clearInterval(bambooSpawner);
                }
            }, 1000); // 1ç§’é–“éš”ã«çŸ­ç¸®
        }

        // PWA ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆå‹•çš„ç”Ÿæˆ
        function generateManifest() {
            const manifest = {
                name: "ç«¹åˆ‡ã‚Šã‚²ãƒ¼ãƒ  - çˆ½å¿«æ–¬æ’ƒä½“é¨“",
                short_name: "ç«¹åˆ‡ã‚Š",
                description: "ãƒªã‚¢ãƒ«ãªç‰©ç†æ¼”ç®—ã§ç«¹ã‚’ã‚¹ãƒ‘ãƒƒã¨åˆ‡ã‚‹çˆ½å¿«ã‚²ãƒ¼ãƒ ",
                start_url: "./index.html",
                display: "standalone",
                background_color: "#2E7D32",
                theme_color: "#2E7D32",
                orientation: "any",
                icons: [
                    {
                        src: "data:image/svg+xml;base64," + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 192">
                                <rect fill="#2E7D32" width="192" height="192"/>
                                <rect fill="#4CAF50" x="60" y="20" width="20" height="152" rx="10"/>
                                <rect fill="#66BB6A" x="80" y="30" width="20" height="132" rx="10"/>
                                <rect fill="#4CAF50" x="100" y="25" width="20" height="142" rx="10"/>
                                <path fill="#FFEB3B" d="M50 80 L140 60 L145 65 L55 85 Z"/>
                                <text x="96" y="185" font-family="sans-serif" font-size="20" text-anchor="middle" fill="white">ğŸ‹</text>
                            </svg>
                        `),
                        sizes: "192x192",
                        type: "image/svg+xml"
                    }
                ]
            };
            
            const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
            const manifestURL = URL.createObjectURL(blob);
            document.getElementById('manifest-placeholder').href = manifestURL;
        }

        // åˆæœŸåŒ–
        generateManifest();
        gameLoop();
    </script>
</body>
</html>